<!-- This file can be parsed by haxe.rtti.XmlParser -->
<haxe>
	<class path="Array" params="T" file="/usr/share/haxe/std/Array.hx" extern="1">
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` Array.</haxe_doc>
		</length>
		<concat public="1" set="method">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns a new Array by appending the elements of `a` to the elements of
		`this` Array.

		This operation does not modify `this` Array.

		If `a` is the empty Array `[]`, a copy of `this` Array is returned.

		The length of the returned Array is equal to the sum of `this.length`
		and `a.length`.

		If `a` is `null`, the result is unspecified.</haxe_doc>
		</concat>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representation of `this` Array, with `sep` separating
		each element.

		The result of this operation is equal to `Std.string(this[0]) + sep +
		Std.string(this[1]) + sep + ... + sep + Std.string(this[this.length-1])`

		If `this` is the empty Array `[]`, the result is the empty String `""`.
		If `this` has exactly one element, the result is equal to a call to
		`Std.string(this[0])`.

		If `sep` is null, the result is unspecified.</haxe_doc>
		</join>
		<pop public="1" set="method">
			<f a=""><x path="Null"><c path="Array.T"/></x></f>
			<haxe_doc>Removes the last element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this.length` will decrease by 1.

		If `this` is the empty Array `[]`, null is returned and the length
		remains 0.</haxe_doc>
		</pop>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Adds the element `x` at the end of `this` Array and returns the new
		length of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` increases by 1.</haxe_doc>
		</push>
		<reverse public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[Reverse the order of elements of `this` Array.

		This operation modifies `this` Array in place.

		If `this.length < 2`, `this` remains unchanged.]]></haxe_doc>
		</reverse>
		<shift public="1" set="method">
			<f a=""><x path="Null"><c path="Array.T"/></x></f>
			<haxe_doc>Removes the first element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this`.length and the index of each
		remaining element is decreased by 1.

		If `this` is the empty Array `[]`, `null` is returned and the length
		remains 0.</haxe_doc>
		</shift>
		<slice public="1" set="method">
			<f a="pos:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Creates a shallow copy of the range of `this` Array, starting at and
		including `pos`, up to but not including `end`.

		This operation does not modify `this` Array.

		The elements are not copied and retain their identity.

		If `end` is omitted or exceeds `this.length`, it defaults to the end of
		`this` Array.

		If `pos` or `end` are negative, their offsets are calculated from the
		end of `this` Array by `this.length + pos` and `this.length + end`
		respectively. If this yields a negative value, 0 is used instead.

		If `pos` exceeds `this.length` or if `end` is less than or equals
		`pos`, the result is `[]`.</haxe_doc>
		</slice>
		<sort public="1" set="method">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts `this` Array according to the comparison function `f`, where
		`f(x,y)` returns 0 if x == y, a positive Int if x > y and a
		negative Int if x < y.

		This operation modifies `this` Array in place.

		The sort operation is not guaranteed to be stable, which means that the
		order of equal elements may not be retained. For a stable Array sorting
		algorithm, `haxe.ds.ArraySort.sort()` can be used instead.

		If `f` is null, the result is unspecified.]]></haxe_doc>
		</sort>
		<splice public="1" set="method">
			<f a="pos:len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc><![CDATA[Removes `len` elements from `this` Array, starting at and including
		`pos`, an returns them.

		This operation modifies `this` Array in place.

		If `len` is < 0 or `pos` exceeds `this`.length, an empty Array [] is
		returned and `this` Array is unchanged.

		If `pos` is negative, its value is calculated from the end	of `this`
		Array by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the sum of the resulting values for `len` and `pos` exceed
		`this.length`, this operation will affect the elements from `pos` to the
		end of `this` Array.

		The length of the returned Array is equal to the new length of `this`
		Array subtracted from the original length of `this` Array. In other
		words, each element of the original `this` Array either remains in
		`this` Array or becomes an element of the returned Array.]]></haxe_doc>
		</splice>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Array.

		The result will include the individual elements' String representations
		separated by comma. The enclosing [ ] may be missing on some platforms,
		use `Std.string()` to get a String representation that is consistent
		across platforms.</haxe_doc>
		</toString>
		<unshift public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds the element `x` at the start of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` and the index of each Array element increases by 1.</haxe_doc>
		</unshift>
		<insert public="1" set="method">
			<f a="pos:x">
				<x path="Int"/>
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Inserts the element `x` at the position `pos`.

		This operation modifies `this` Array in place.

		The offset is calculated like so:

		- If `pos` exceeds `this.length`, the offset is `this.length`.
		- If `pos` is negative, the offset is calculated from the end of `this`
		  Array, i.e. `this.length + pos`. If this yields a negative value, the
		  offset is 0.
		- Otherwise, the offset is `pos`.

		If the resulting offset does not exceed `this.length`, all elements from
		and including that offset to the end of `this` Array are moved one index
		ahead.</haxe_doc>
		</insert>
		<remove public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurrence of `x` in `this` Array.

		This operation modifies `this` Array in place.

		If `x` is found by checking standard equality, it is removed from `this`
		Array and all following elements are reindexed accordingly. The function
		then returns true.

		If `x` is not found, `this` Array is not changed and the function
		returns false.</haxe_doc>
		</remove>
		<indexOf public="1" set="method">
			<f a="x:?fromIndex">
				<c path="Array.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the first occurrence of `x` in `this` Array, searching front to back.

		If `x` is found by checking standard equality, the function returns its index.

		If `x` is not found, the function returns -1.

		If `fromIndex` is specified, it will be used as the starting index to search from,
		otherwise search starts with zero index. If it is negative, it will be taken as the
		offset from the end of `this` Array to compute the starting index. If given or computed
		starting index is less than 0, the whole array will be searched, if it is greater than
		or equal to the length of `this` Array, the function returns -1.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="x:?fromIndex">
				<c path="Array.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the last occurrence of `x` in `this` Array, searching back to front.

		If `x` is found by checking standard equality, the function returns its index.

		If `x` is not found, the function returns -1.

		If `fromIndex` is specified, it will be used as the starting index to search from,
		otherwise search starts with the last element index. If it is negative, it will be
		taken as the offset from the end of `this` Array to compute the starting index. If
		given or computed starting index is greater than or equal to the length of `this` Array,
		the whole array will be searched, if it is less than 0, the function returns -1.</haxe_doc>
		</lastIndexOf>
		<copy public="1" set="method">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>Returns a shallow copy of `this` Array.

		The elements are not copied and retain their identity, so
		`a[i] == a.copy()[i]` is true for any valid `i`. However,
		`a == a.copy()` is always false.</haxe_doc>
		</copy>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="Array.T"/></t></f>
			<haxe_doc>Returns an iterator of the Array values.</haxe_doc>
		</iterator>
		<map public="1" params="S" get="inline" set="null" line="277">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<c path="map.S"/>
				</f>
				<c path="Array"><c path="map.S"/></c>
			</f>
			<meta><m n=":runtime"/></meta>
			<haxe_doc>Creates a new Array by applying function `f` to all elements of `this`.

		The order of elements is preserved.

		If `f` is null, the result is unspecified.</haxe_doc>
		</map>
		<filter public="1" get="inline" set="null" line="295">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<x path="Bool"/>
				</f>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<meta><m n=":runtime"/></meta>
			<haxe_doc>Returns an Array containing those elements of `this` for which `f`
		returned true.

		The individual elements are not duplicated and retain their identity.

		If `f` is null, the result is unspecified.</haxe_doc>
		</filter>
		<resize public="1" set="method">
			<f a="len">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the length of the Array.

		If `len` is shorter than the array's current size, the last
		`length - len` elements will be removed. If `len` is longer, the Array
		will be extended, with new elements set to a target-specific default
		value:

		- always null on dynamic targets
		- 0, 0.0 or false for Int, Float and Bool respectively on static targets
		- null for other types on static targets</haxe_doc>
		</resize>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Array.</haxe_doc>
		</new>
		<haxe_doc>An Array is a storage for values. You can access it using indexes or
	with its API.

	@see https://haxe.org/manual/std-Array.html
	@see https://haxe.org/manual/lf-array-comprehension.html</haxe_doc>
	</class>
	<abstract path="Class" params="T" file="/usr/share/haxe/std/Class.hx">
		<this><x path="Class"><c path="Class.T"/></x></this>
		<haxe_doc>An abstract type that represents a Class.

	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-class-instance.html</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Enum" params="T" file="/usr/share/haxe/std/Enum.hx">
		<this><x path="Enum"><c path="Enum.T"/></x></this>
		<haxe_doc>An abstract type that represents an Enum type.

	The corresponding enum instance type is `EnumValue`.

	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-enum-instance.html</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="EnumValue" params="" file="/usr/share/haxe/std/EnumValue.hx">
		<this><x path="EnumValue"/></this>
		<haxe_doc>An abstract type that represents any enum value.
	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-enum-instance.html</haxe_doc>
		<meta><m n=":coreType"/></meta>
		<impl><class path="_EnumValue.EnumValue_Impl_" params="" file="/usr/share/haxe/std/EnumValue.hx" private="1" module="EnumValue"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<typedef path="Map" params="K:V" file="/usr/share/haxe/std/Map.hx"><x path="haxe.ds.Map">
	<c path="Map.K"/>
	<c path="Map.V"/>
</x></typedef>
	<typedef path="IMap" params="K:V" file="/usr/share/haxe/std/Map.hx" module="Map">
		<c path="haxe.IMap">
			<c path="IMap.K"/>
			<c path="IMap.V"/>
		</c>
		<meta>
			<m n=":dox"><e>hide</e></m>
			<m n=":deprecated"/>
		</meta>
	</typedef>
	<class path="Math" params="" file="/usr/share/haxe/std/Math.hx" extern="1">
		<PI public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>Represents the ratio of the circumference of a circle to its diameter,
		specified by the constant, π. `PI` is approximately 3.141592653589793.</haxe_doc>
		</PI>
		<NEGATIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special `Float` constant which denotes negative infinity.

		For example, this is the result of -1.0 / 0.0.

		Operations with `NEGATIVE_INFINITY` as an operand may result in
		`NEGATIVE_INFINITY`, `POSITIVE_INFINITY` or `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.</haxe_doc>
		</NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special `Float` constant which denotes positive infinity.

		For example, this is the result of 1.0 / 0.0.

		Operations with `POSITIVE_INFINITY` as an operand may result in
		`NEGATIVE_INFINITY`, `POSITIVE_INFINITY` or `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.</haxe_doc>
		</POSITIVE_INFINITY>
		<NaN public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special `Float` constant which denotes an invalid number.

		NaN stands for "Not a Number". It occurs when a mathematically incorrect
		operation is executed, such as taking the square root of a negative
		number: Math.sqrt(-1).

		All further operations with `NaN` as an operand will result in `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.

		In order to test if a value is `NaN`, you should use `Math.isNaN()` function.</haxe_doc>
		</NaN>
		<abs public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the absolute value of `v`.

		If `v` is positive or 0, the result is unchanged. Otherwise the result
		is -`v`.

		If `v` is `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`, the result is
		`POSITIVE_INFINITY`.

		If `v` is `NaN`, the result is `NaN`.</haxe_doc>
		</abs>
		<min public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the smaller of values `a` and `b`.

		If `a` or `b` are `NaN`, the result is `NaN`.
		If `a` or `b` are `NEGATIVE_INFINITY`, the result is `NEGATIVE_INFINITY`.
		If `a` and `b` are `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.</haxe_doc>
		</min>
		<max public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the greater of values `a` and `b`.

		If `a` or `b` are `NaN`, the result is `NaN`.
		If `a` or `b` are `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		If `a` and `b` are `NEGATIVE_INFINITY`, the result is `NEGATIVE_INFINITY`.</haxe_doc>
		</max>
		<sin public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric sine of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</sin>
		<cos public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric cosine of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</cos>
		<tan public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric tangent of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</tan>
		<asin public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</asin>
		<acos public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc cosine of the specified angle `v`,
		in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</acos>
		<atan public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc tangent of the specified angle `v`,
		in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</atan>
		<atan2 public="1" set="method" static="1">
			<f a="y:x">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc tangent whose tangent is the quotient of
		two specified numbers, in radians.

		If parameter `x` or `y`  is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`,
		the result is `NaN`.</haxe_doc>
		</atan2>
		<exp public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns Euler's number, raised to the power of `v`.

		exp(1.0) is approximately 2.718281828459.

		If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		If `v` is `NEGATIVE_INFINITY`, the result is `0.0`.
		If `v` is `NaN`, the result is `NaN`.</haxe_doc>
		</exp>
		<log public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the natural logarithm of `v`.

		This is the mathematical inverse operation of exp,
		i.e. `log(exp(v)) == v` always holds.

		If `v` is negative (including `NEGATIVE_INFINITY`) or `NaN`, the result
		is `NaN`.
		If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		If `v` is `0.0`, the result is `NEGATIVE_INFINITY`.</haxe_doc>
		</log>
		<pow public="1" set="method" static="1">
			<f a="v:exp">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns a specified base `v` raised to the specified power `exp`.</haxe_doc>
		</pow>
		<sqrt public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the square root of `v`.

		If `v` is negative (including `NEGATIVE_INFINITY`) or `NaN`, the result
		is `NaN`.
		If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		If `v` is `0.0`, the result is `0.0`.</haxe_doc>
		</sqrt>
		<round public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Rounds `v` to the nearest integer value.

		Ties are rounded up, so that `0.5` becomes `1` and `-0.5` becomes `0`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</round>
		<floor public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the largest integer value that is not greater than `v`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</floor>
		<ceil public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the smallest integer value that is not less than `v`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</ceil>
		<random public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns a pseudo-random number which is greater than or equal to 0.0,
		and less than 1.0.</haxe_doc>
		</random>
		<ffloor public="1" get="inline" set="null" line="263" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></ffloor>
		<fceil public="1" get="inline" set="null" line="267" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></fceil>
		<fround public="1" get="inline" set="null" line="271" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></fround>
		<isFinite public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is a finite number.

		If `f` is `POSITIVE_INFINITY`, `NEGATIVE_INFINITY` or `NaN`, the result
		is `false`, otherwise the result is `true`.</haxe_doc>
		</isFinite>
		<isNaN public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is not a valid number.

		If `f` is `NaN`, the result is `true`, otherwise the result is `false`.
		In particular, both `POSITIVE_INFINITY` and `NEGATIVE_INFINITY` are
		not considered `NaN`.</haxe_doc>
		</isNaN>
		<haxe_doc>This class defines mathematical functions and constants.

	@see https://haxe.org/manual/std-math.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="Reflect" params="" file="/usr/share/haxe/std/Reflect.hx" extern="1">
		<hasField public="1" set="method" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if structure `o` has a field named `field`.

		This is only guaranteed to work for anonymous structures. Refer to
		`Type.getInstanceFields` for a function supporting class instances.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</hasField>
		<field public="1" set="method" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Returns the value of the field named `field` on object `o`.

		If `o` is not an object or has no field named `field`, the result is
		null.

		If the field is defined as a property, its accessors are ignored. Refer
		to `Reflect.getProperty` for a function supporting property accessors.

		If `field` is null, the result is unspecified.

		(As3) If used on a property field, the getter will be invoked. It is
		not possible to obtain the value directly.</haxe_doc>
		</field>
		<setField public="1" set="method" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the field named `field` of object `o` to value `value`.

		If `o` has no field named `field`, this function is only guaranteed to
		work for anonymous structures.

		If `o` or `field` are null, the result is unspecified.

		(As3) If used on a property field, the setter will be invoked. It is
		not possible to set the value directly.</haxe_doc>
		</setField>
		<getProperty public="1" set="method" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Returns the value of the field named `field` on object `o`, taking
		property getter functions into account.

		If the field is not a property, this function behaves like
		`Reflect.field`, but might be slower.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</getProperty>
		<setProperty public="1" set="method" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the field named `field` of object `o` to value `value`, taking
		property setter functions into account.

		If the field is not a property, this function behaves like
		`Reflect.setField`, but might be slower.

		If `field` is null, the result is unspecified.</haxe_doc>
		</setProperty>
		<callMethod public="1" set="method" static="1">
			<f a="o:func:args">
				<d/>
				<x path="haxe.Function"/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>Call a method `func` with the given arguments `args`.

		The object `o` is ignored in most cases. It serves as the `this`-context in the following
		situations:

		* (neko) Allows switching the context to `o` in all cases.
		* (macro) Same as neko for Haxe 3. No context switching in Haxe 4.
		* (js, lua) Require the `o` argument if `func` does not, but should have a context.
			This can occur by accessing a function field natively, e.g. through `Reflect.field`
			or by using `(object : Dynamic).field`. However, if `func` has a context, `o` is
			ignored like on other targets.</haxe_doc>
		</callMethod>
		<fields public="1" set="method" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the fields of structure `o`.

		This method is only guaranteed to work on anonymous structures. Refer to
		`Type.getInstanceFields` for a function supporting class instances.

		If `o` is null, the result is unspecified.</haxe_doc>
		</fields>
		<isFunction public="1" set="method" static="1">
			<f a="f">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if `f` is a function, false otherwise.

		If `f` is null, the result is false.</haxe_doc>
		</isFunction>
		<compare public="1" params="T" set="method" static="1">
			<f a="a:b">
				<c path="compare.T"/>
				<c path="compare.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Compares `a` and `b`.

		If `a` is less than `b`, the result is negative. If `b` is less than
		`a`, the result is positive. If `a` and `b` are equal, the result is 0.

		This function is only defined if `a` and `b` are of the same type.

		If that type is a function, the result is unspecified and
		`Reflect.compareMethods` should be used instead.

		For all other types, the result is 0 if `a` and `b` are equal. If they
		are not equal, the result depends on the type and is negative if:

		- Numeric types: a is less than b
		- String: a is lexicographically less than b
		- Other: unspecified

		If `a` and `b` are null, the result is 0. If only one of them is null,
		the result is unspecified.</haxe_doc>
		</compare>
		<compareMethods public="1" set="method" static="1">
			<f a="f1:f2">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Compares the functions `f1` and `f2`.

		If `f1` or `f2` are null, the result is false.
		If `f1` or `f2` are not functions, the result is unspecified.

		Otherwise the result is true if `f1` and the `f2` are physically equal,
		false otherwise.

		If `f1` or `f2` are member method closures, the result is true if they
		are closures of the same method on the same object value, false otherwise.</haxe_doc>
		</compareMethods>
		<isObject public="1" set="method" static="1">
			<f a="v">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[Tells if `v` is an object.

		The result is true if `v` is one of the following:

		- class instance
		- structure
		- `Class<T>`
		- `Enum<T>`

		Otherwise, including if `v` is null, the result is false.]]></haxe_doc>
		</isObject>
		<isEnumValue public="1" set="method" static="1">
			<f a="v">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `v` is an enum value.

		The result is true if `v` is of type EnumValue, i.e. an enum
		constructor.

		Otherwise, including if `v` is null, the result is false.</haxe_doc>
		</isEnumValue>
		<deleteField public="1" set="method" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the field named `field` from structure `o`.

		This method is only guaranteed to work on anonymous structures.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</deleteField>
		<copy public="1" params="T" set="method" static="1">
			<f a="o">
				<x path="Null"><c path="copy.T"/></x>
				<x path="Null"><c path="copy.T"/></x>
			</f>
			<haxe_doc>Copies the fields of structure `o`.

		This is only guaranteed to work on anonymous structures.

		If `o` is null, the result is `null`.</haxe_doc>
		</copy>
		<makeVarArgs public="1" set="method" static="1">
			<f a="f">
				<f a="">
					<c path="Array"><d/></c>
					<d/>
				</f>
				<d/>
			</f>
			<haxe_doc>Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.</haxe_doc>
			<overloads><makeVarArgs public="1" set="method">
	<f a="f">
		<f a="">
			<c path="Array"><d/></c>
			<x path="Void"/>
		</f>
		<d/>
	</f>
	<haxe_doc>Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.</haxe_doc>
</makeVarArgs></overloads>
		</makeVarArgs>
		<haxe_doc>The Reflect API is a way to manipulate values dynamically through an
	abstract interface in an untyped manner. Use with care.

	@see https://haxe.org/manual/std-reflection.html</haxe_doc>
	</class>
	<class path="Std" params="" file="/usr/share/haxe/std/Std.hx" extern="1">
		<is public="1" set="method" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if a value `v` is of the type `t`. Returns `false` if `v` or `t` are null.

		If `t` is a class or interface with `@:generic` meta, the result is `false`.</haxe_doc>
		</is>
		<downcast public="1" params="T:S" set="method" static="1">
			<f a="value:c">
				<c path="downcast.T"/>
				<x path="Class"><c path="downcast.S"/></x>
				<c path="downcast.S"/>
			</f>
			<haxe_doc>Checks if object `value` is an instance of class or interface `c`.

		Compiles only if the type specified by `c` can be assigned to the type
		of `value`.

		This method checks if a downcast is possible. That is, if the runtime
		type of `value` is assignable to the type specified by `c`, `value` is
		returned. Otherwise null is returned.

		This method is not guaranteed to work with core types such as `String`,
		`Array` and `Date`.

		If `value` is null, the result is null. If `c` is null, the result is
		unspecified.</haxe_doc>
		</downcast>
		<instance public="1" params="T:S" set="method" static="1">
			<f a="value:c">
				<c path="instance.T"/>
				<x path="Class"><c path="instance.S"/></x>
				<c path="instance.S"/>
			</f>
			<meta><m n=":deprecated"><e>"Std.instance() is deprecated. Use Std.downcast() instead."</e></m></meta>
		</instance>
		<string public="1" set="method" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Converts any value to a String.

		If `s` is of `String`, `Int`, `Float` or `Bool`, its value is returned.

		If `s` is an instance of a class and that class or one of its parent classes has
		a `toString` method, that method is called. If no such method is present, the result
		is unspecified.

		If `s` is an enum constructor without argument, the constructor's name is returned. If
		arguments exists, the constructor's name followed by the String representations of
		the arguments is returned.

		If `s` is a structure, the field names along with their values are returned. The field order
		and the operator separating field names and values are unspecified.

		If s is null, "null" is returned.</haxe_doc>
		</string>
		<int public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Converts a `Float` to an `Int`, rounded towards 0.

		If `x` is outside of the signed Int32 range, or is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</int>
		<parseInt public="1" set="method" static="1">
			<f a="x">
				<c path="String"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<haxe_doc>Converts a `String` to an `Int`.

		Leading whitespaces are ignored.

		If `x` starts with 0x or 0X, hexadecimal notation is recognized where the following digits may
		contain 0-9 and A-F.

		Otherwise `x` is read as decimal number with 0-9 being allowed characters. `x` may also start with
		a - to denote a negative value.

		In decimal mode, parsing continues until an invalid character is detected, in which case the
		result up to that point is returned. For hexadecimal notation, the effect of invalid characters
		is unspecified.

		Leading 0s that are not part of the 0x/0X hexadecimal notation are ignored, which means octal
		notation is not supported.

		If `x` is null, the result is unspecified.
		If `x` cannot be parsed as integer, the result is `null`.</haxe_doc>
		</parseInt>
		<parseFloat public="1" set="method" static="1">
			<f a="x">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Converts a `String` to a `Float`.

		The parsing rules for `parseInt` apply here as well, with the exception of invalid input
		resulting in a `NaN` value instead of null.

		Additionally, decimal notation may contain a single `.` to denote the start of the fractions.</haxe_doc>
		</parseFloat>
		<random public="1" set="method" static="1">
			<f a="x">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc><![CDATA[Return a random integer between 0 included and `x` excluded.

		If `x <= 1`, the result is always 0.]]></haxe_doc>
		</random>
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="Void" params="" file="/usr/share/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Void"/></this>
		<haxe_doc>The standard `Void` type. Only `null` values can be of the type `Void`.

	@see https://haxe.org/manual/types-void.html</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<abstract path="Float" params="" file="/usr/share/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Float"/></this>
		<haxe_doc><![CDATA[The standard `Float` type, this is a double-precision IEEE 64bit float.

	On static targets, `null` cannot be assigned to Float. If this is necessary,
	`Null<Float>` can be used instead.

	`Std.int` converts a `Float` to an `Int`, rounded towards 0.
	`Std.parseFloat` converts a `String` to a `Float`.

	@see https://haxe.org/manual/types-basic-types.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Int" params="" file="/usr/share/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Int"/></this>
		<to><icast><x path="Float"/></icast></to>
		<haxe_doc><![CDATA[The standard `Int` type. Its precision depends on the platform.

	On static targets, `null` cannot be assigned to `Int`. If this is necessary,
	`Null<Int>` can be used instead.

	`Std.int` converts a `Float` to an `Int`, rounded towards 0.
	`Std.parseInt` converts a `String` to an `Int`.

	@see https://haxe.org/manual/types-basic-types.html
	@see https://haxe.org/manual/std-math-integer-math.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Null" params="T" file="/usr/share/haxe/std/StdTypes.hx" module="StdTypes">
		<from><icast><c path="Null.T"/></icast></from>
		<this><x path="Null"><c path="Null.T"/></x></this>
		<to><icast><c path="Null.T"/></icast></to>
		<haxe_doc><![CDATA[`Null<T>` is a wrapper that can be used to make the basic types `Int`,
	`Float` and `Bool` nullable on static targets.

	If null safety is enabled, only types wrapped in `Null<T>` are nullable.

	Otherwise, it has no effect on non-basic-types, but it can be useful as a way to document
	that `null` is an acceptable value for a method argument, return value or variable.

	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":forward"/>
			<m n=":coreType"/>
		</meta>
	</abstract>
	<abstract path="Bool" params="" file="/usr/share/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Bool"/></this>
		<haxe_doc><![CDATA[The standard Boolean type, which can either be `true` or `false`.

	On static targets, `null` cannot be assigned to `Bool`. If this is necessary,
	`Null<Bool>` can be used instead.

	@see https://haxe.org/manual/types-bool.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Dynamic" params="T" file="/usr/share/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Dynamic"><c path="Dynamic.T"/></x></this>
		<haxe_doc>`Dynamic` is a special type which is compatible with all other types.

	Use of `Dynamic` should be minimized as it prevents several compiler
	checks and optimizations. See `Any` type for a safer alternative for
	representing values of any type.

	@see https://haxe.org/manual/types-dynamic.html</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Iterator" params="T" file="/usr/share/haxe/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method">
				<f a=""><c path="Iterator.T"/></f>
				<haxe_doc>Returns the current item of the `Iterator` and advances to the next one.

		This method is not required to check `hasNext()` first. A call to this
		method while `hasNext()` is `false` yields unspecified behavior.

		On the other hand, iterators should not require a call to `hasNext()`
		before the first call to `next()` if an element is available.</haxe_doc>
			</next>
			<hasNext set="method">
				<f a=""><x path="Bool"/></f>
				<haxe_doc>Returns `false` if the iteration is complete, `true` otherwise.

		Usually iteration is considered to be complete if all elements of the
		underlying data structure were handled through calls to `next()`. However,
		in custom iterators any logic may be used to determine the completion
		state.</haxe_doc>
			</hasNext>
		</a>
		<haxe_doc>An `Iterator` is a structure that permits iteration over elements of type `T`.

	Any class with matching `hasNext()` and `next()` fields is considered an `Iterator`
	and can then be used e.g. in `for`-loops. This makes it easy to implement
	custom iterators.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="/usr/share/haxe/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An `Iterable` is a data structure which has an `iterator()` method.
	See `Lambda` for generic functions on iterable structures.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
	</typedef>
	<typedef path="KeyValueIterator" params="K:V" file="/usr/share/haxe/std/StdTypes.hx" module="StdTypes">
		<t path="Iterator"><a>
	<value><c path="KeyValueIterator.V"/></value>
	<key><c path="KeyValueIterator.K"/></key>
</a></t>
		<haxe_doc>A `KeyValueIterator` is an `Iterator` that has a key and a value.</haxe_doc>
	</typedef>
	<typedef path="KeyValueIterable" params="K:V" file="/usr/share/haxe/std/StdTypes.hx" module="StdTypes">
		<a><keyValueIterator set="method"><f a=""><t path="KeyValueIterator">
	<c path="KeyValueIterable.K"/>
	<c path="KeyValueIterable.V"/>
</t></f></keyValueIterator></a>
		<haxe_doc>A `KeyValueIterable` is a data structure which has a `keyValueIterator()`
	method to iterate over key-value-pairs.</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="/usr/share/haxe/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>`ArrayAccess` is used to indicate a class that can be accessed using brackets.
	The type parameter represents the type of the elements stored.

	This interface should be used for externs only. Haxe does not support custom
	array access on classes. However, array access can be implemented for
	abstract types.

	@see https://haxe.org/manual/types-abstract-array-access.html</haxe_doc></class>
	<class path="String" params="" file="/usr/share/haxe/std/String.hx" extern="1">
		<fromCharCode public="1" set="method" static="1">
			<f a="code">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the String corresponding to the character code `code`.

		If `code` is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</fromCharCode>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The number of characters in `this` String.</haxe_doc>
		</length>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are upper case.</haxe_doc>
		</toUpperCase>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are lower case.</haxe_doc>
		</toLowerCase>
		<charAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, the empty String `""`
		is returned.</haxe_doc>
		</charAt>
		<charCodeAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<haxe_doc>Returns the character code at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, `null` is returned.

		To obtain the character code of a single character, `"x".code` can be
		used instead to inline the character code at compile time. Note that
		this only works on String literals of length 1.</haxe_doc>
		</charCodeAt>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the leftmost occurrence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String starting from `startIndex` (if `startIndex` is posivite
		or 0) or `max(this.length + startIndex, 0)` (if `startIndex` is negative).

		If `startIndex` exceeds `this.length`, -1 is returned.

		Otherwise the search is performed within `this` String. In either case,
		the returned position is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the rightmost occurrence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String from 0 to `startIndex + str.length`. Otherwise the search
		is performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</lastIndexOf>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits `this` String at each occurrence of `delimiter`.

		If `this` String is the empty String `""`, the result is not consistent
		across targets and may either be `[]` (on Js, Cpp) or `[""]`.

		If `delimiter` is the empty String `""`, `this` String is split into an
		Array of `this.length` elements, where the elements correspond to the
		characters of `this` String.

		If `delimiter` is not found within `this` String, the result is an Array
		with one element, which equals `this` String.

		If `delimiter` is null, the result is unspecified.

		Otherwise, `this` String is split into parts at each occurrence of
		`delimiter`. If `this` String starts (or ends) with `delimiter`, the
		result `Array` contains a leading (or trailing) empty String `""` element.
		Two subsequent delimiters also result in an empty String `""` element.</haxe_doc>
		</split>
		<substr public="1" set="method">
			<f a="pos:?len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns `len` characters of `this` String, starting at position `pos`.

		If `len` is omitted, all characters from position `pos` to the end of
		`this` String are included.

		If `pos` is negative, its value is calculated from the end of `this`
		String by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the calculated position + `len` exceeds `this.length`, the characters
		from that position to the end of `this` String are returned.

		If `len` is negative, the result is unspecified.</haxe_doc>
		</substr>
		<substring public="1" set="method">
			<f a="startIndex:?endIndex">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the part of `this` String from `startIndex` to but not including `endIndex`.

		If `startIndex` or `endIndex` are negative, 0 is used instead.

		If `startIndex` exceeds `endIndex`, they are swapped.

		If the (possibly swapped) `endIndex` is omitted or exceeds
		`this.length`, `this.length` is used instead.

		If the (possibly swapped) `startIndex` exceeds `this.length`, the empty
		String `""` is returned.</haxe_doc>
		</substring>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.

	A Haxe String is immutable, it is not possible to modify individual
	characters. No method of this class changes the state of `this` String.

	Strings can be constructed using the String literal syntax `"string value"`.

	String can be concatenated by using the `+` operator. If an operand is not a
	String, it is passed through `Std.string()` first.

	@see https://haxe.org/manual/std-String.html</haxe_doc>
	</class>
	<class path="Sys" params="" file="/usr/share/haxe/std/Sys.hx" extern="1">
		<print public="1" set="method" static="1">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Prints any value to the standard output.</haxe_doc>
		</print>
		<println public="1" set="method" static="1">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Prints any value to the standard output, followed by a newline.
		On Windows, this function outputs a CRLF newline.
		LF newlines are printed on all other platforms.</haxe_doc>
		</println>
		<args public="1" set="method" static="1">
			<f a=""><c path="Array"><c path="String"/></c></f>
			<haxe_doc>Returns all the arguments that were passed in the command line.
		This does not include the interpreter or the name of the program file.

		(java)(eval) On Windows, non-ASCII Unicode arguments will not work correctly.

		(cs) Non-ASCII Unicode arguments will not work correctly.</haxe_doc>
		</args>
		<getEnv public="1" set="method" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the value of the given environment variable, or `null` if it
		doesn't exist.</haxe_doc>
		</getEnv>
		<putEnv public="1" set="method" static="1">
			<f a="s:v">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the value of the given environment variable.

		(java) This functionality is not available on Java; calling this function will throw.</haxe_doc>
		</putEnv>
		<environment public="1" set="method" static="1">
			<f a=""><t path="Map">
	<c path="String"/>
	<c path="String"/>
</t></f>
			<haxe_doc>Returns all environment variables.</haxe_doc>
		</environment>
		<sleep public="1" set="method" static="1">
			<f a="seconds">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Suspends execution for the given length of time (in seconds).</haxe_doc>
		</sleep>
		<setTimeLocale public="1" set="method" static="1">
			<f a="loc">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Changes the current time locale, which will affect `DateTools.format` date formating.
		Returns `true` if the locale was successfully changed.</haxe_doc>
		</setTimeLocale>
		<getCwd public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Gets the current working directory (usually the one in which the program was started).</haxe_doc>
		</getCwd>
		<setCwd public="1" set="method" static="1">
			<f a="s">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Changes the current working directory.

		(java) This functionality is not available on Java; calling this function will throw.</haxe_doc>
		</setCwd>
		<systemName public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the type of the current system. Possible values are:
		 - `"Windows"`
		 - `"Linux"`
		 - `"BSD"`
		 - `"Mac"`</haxe_doc>
		</systemName>
		<command public="1" set="method" static="1">
			<f a="cmd:?args">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<x path="Int"/>
			</f>
			<haxe_doc>Runs the given command. The command output will be printed to the same output as the current process.
		The current process will block until the command terminates.
		The return value is the exit code of the command (usually `0` indicates no error).

		Command arguments can be passed in two ways:

		 1. Using `args` to pass command arguments. Each argument will be automatically quoted and shell meta-characters will be escaped if needed.
		`cmd` should be an executable name that can be located in the `PATH` environment variable, or a full path to an executable.

		 2. When `args` is not given or is `null`, command arguments can be appended to `cmd`. No automatic quoting/escaping will be performed. `cmd` should be formatted exactly as it would be when typed at the command line.
		It can run executables, as well as shell commands that are not executables (e.g. on Windows: `dir`, `cd`, `echo` etc).

		Use the `sys.io.Process` API for more complex tasks, such as background processes, or providing input to the command.</haxe_doc>
		</command>
		<exit public="1" set="method" static="1">
			<f a="code">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Exits the current process with the given exit code.

		(macro)(eval) Being invoked in a macro or eval context (e.g. with `-x` or `--run`) immediately terminates
		the compilation process, which also prevents the execution of any `--next` sections of compilation arguments.</haxe_doc>
		</exit>
		<time public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Gives the most precise timestamp value available (in seconds).</haxe_doc>
		</time>
		<cpuTime public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Gives the most precise timestamp value available (in seconds),
		but only accounts for the actual time spent running on the CPU for the current thread/process.</haxe_doc>
		</cpuTime>
		<executablePath public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":deprecated"><e>"Use programPath instead"</e></m></meta>
			<haxe_doc>Returns the path to the current executable that we are running.</haxe_doc>
		</executablePath>
		<programPath public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the absolute path to the current program file that we are running.
		Concretely, for an executable binary, it returns the path to the binary.
		For a script (e.g. a PHP file), it returns the path to the script.</haxe_doc>
		</programPath>
		<getChar public="1" set="method" static="1">
			<f a="echo">
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Reads a single input character from the standard input and returns it.
		Setting `echo` to `true` will also display the character on the output.</haxe_doc>
		</getChar>
		<stdin public="1" set="method" static="1">
			<f a=""><c path="haxe.io.Input"/></f>
			<haxe_doc>Returns the standard input of the process, from which user input can be read.
		Usually it will block until the user sends a full input line.
		See `getChar` for an alternative.</haxe_doc>
		</stdin>
		<stdout public="1" set="method" static="1">
			<f a=""><c path="haxe.io.Output"/></f>
			<haxe_doc>Returns the standard output of the process, to which program output can be written.</haxe_doc>
		</stdout>
		<stderr public="1" set="method" static="1">
			<f a=""><c path="haxe.io.Output"/></f>
			<haxe_doc>Returns the standard error of the process, to which program errors can be written.</haxe_doc>
		</stderr>
		<haxe_doc>This class provides access to various base functions of system platforms.
	Look in the `sys` package for more system APIs.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":require"><e>sys</e></m>
		</meta>
	</class>
	<class path="Type" params="" file="/usr/share/haxe/std/Type.hx" extern="1">
		<getClass public="1" params="T" set="method" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<x path="Class"><c path="getClass.T"/></x>
			</f>
			<haxe_doc>Returns the class of `o`, if `o` is a class instance.

		If `o` is null or of a different type, null is returned.

		In general, type parameter information cannot be obtained at runtime.</haxe_doc>
		</getClass>
		<getEnum public="1" set="method" static="1">
			<f a="o">
				<x path="EnumValue"/>
				<x path="Enum"><d/></x>
			</f>
			<haxe_doc><![CDATA[Returns the enum of enum instance `o`.

		An enum instance is the result of using an enum constructor. Given an
		`enum Color { Red; }`, `getEnum(Red)` returns `Enum<Color>`.

		If `o` is null, null is returned.

		In general, type parameter information cannot be obtained at runtime.]]></haxe_doc>
		</getEnum>
		<getSuperClass public="1" set="method" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<x path="Class"><d/></x>
			</f>
			<haxe_doc>Returns the super-class of class `c`.

		If `c` has no super class, null is returned.

		If `c` is null, the result is unspecified.

		In general, type parameter information cannot be obtained at runtime.</haxe_doc>
		</getSuperClass>
		<getClassName public="1" set="method" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of class `c`, including its path.

		If `c` is inside a package, the package structure is returned dot-
		separated, with another dot separating the class name:
		`pack1.pack2.(...).packN.ClassName`
		If `c` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `c` has no package, the class name is returned.

		If `c` is null, the result is unspecified.

		The class name does not include any type parameters.</haxe_doc>
		</getClassName>
		<getEnumName public="1" set="method" static="1">
			<f a="e">
				<x path="Enum"><d/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.

		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
		`pack1.pack2.(...).packN.EnumName`
		If `e` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `e` has no package, the enum name is returned.

		If `e` is null, the result is unspecified.

		The enum name does not include any type parameters.</haxe_doc>
		</getEnumName>
		<resolveClass public="1" set="method" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Class"><d/></x>
			</f>
			<haxe_doc>Resolves a class by name.

		If `name` is the path of an existing class, that class is returned.

		Otherwise null is returned.

		If `name` is null or the path to a different type, the result is
		unspecified.

		The class name must not include any type parameters.</haxe_doc>
		</resolveClass>
		<resolveEnum public="1" set="method" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Enum"><d/></x>
			</f>
			<haxe_doc>Resolves an enum by name.

		If `name` is the path of an existing enum, that enum is returned.

		Otherwise null is returned.

		If `name` is null the result is unspecified.

		If `name` is the path to a different type, null is returned.

		The enum name must not include any type parameters.</haxe_doc>
		</resolveEnum>
		<createInstance public="1" params="T" set="method" static="1">
			<f a="cl:args">
				<x path="Class"><c path="createInstance.T"/></x>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<haxe_doc>Creates an instance of class `cl`, using `args` as arguments to the
		class constructor.

		This function guarantees that the class constructor is called.

		Default values of constructors arguments are not guaranteed to be
		taken into account.

		If `cl` or `args` are null, or if the number of elements in `args` does
		not match the expected number of constructor arguments, or if any
		argument has an invalid type,  or if `cl` has no own constructor, the
		result is unspecified.

		In particular, default values of constructor arguments are not
		guaranteed to be taken into account.</haxe_doc>
		</createInstance>
		<createEmptyInstance public="1" params="T" set="method" static="1">
			<f a="cl">
				<x path="Class"><c path="createEmptyInstance.T"/></x>
				<c path="createEmptyInstance.T"/>
			</f>
			<haxe_doc>Creates an instance of class `cl`.

		This function guarantees that the class constructor is not called.

		If `cl` is null, the result is unspecified.</haxe_doc>
		</createEmptyInstance>
		<createEnum public="1" params="T" set="method" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createEnum.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createEnum.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.

		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createEnum>
		<createEnumIndex public="1" params="T" set="method" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createEnumIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createEnumIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.

		The constructor indices are preserved from Haxe syntax, so the first
		declared is index 0, the next index 1 etc.

		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createEnumIndex>
		<getInstanceFields public="1" set="method" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the instance fields of class `c`, including
		inherited fields.

		This only includes fields which are known at compile-time. In
		particular, using `getInstanceFields(getClass(obj))` will not include
		any fields which were added to `obj` at runtime.

		The order of the fields in the returned Array is unspecified.

		If `c` is null, the result is unspecified.

		(As3) This method only returns instance fields that are public.</haxe_doc>
		</getInstanceFields>
		<getClassFields public="1" set="method" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of static fields of class `c`.

		This does not include static fields of parent classes.

		The order of the fields in the returned Array is unspecified.

		If `c` is null, the result is unspecified.

		(As3) This method only returns class fields that are public.</haxe_doc>
		</getClassFields>
		<getEnumConstructs public="1" set="method" static="1">
			<f a="e">
				<x path="Enum"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.

		The order of the constructor names in the returned Array is preserved
		from the original syntax.

		If `e` is null, the result is unspecified.</haxe_doc>
		</getEnumConstructs>
		<typeof public="1" set="method" static="1">
			<f a="v">
				<d/>
				<e path="ValueType"/>
			</f>
			<haxe_doc>Returns the runtime type of value `v`.

		The result corresponds to the type `v` has at runtime, which may vary
		per platform. Assumptions regarding this should be minimized to avoid
		surprises.</haxe_doc>
		</typeof>
		<enumEq public="1" params="T" set="method" static="1">
			<f a="a:b">
				<c path="enumEq.T"/>
				<c path="enumEq.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.

		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors, if exists.

		If `a` or `b` are null, the result is unspecified.</haxe_doc>
		</enumEq>
		<enumConstructor public="1" set="method" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.

		The result String does not contain any constructor arguments.

		If `e` is null, the result is unspecified.</haxe_doc>
		</enumConstructor>
		<enumParameters public="1" set="method" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.

		If `e` has no arguments, the result is [].

		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.

		If `e` is null, the result is unspecified.</haxe_doc>
		</enumParameters>
		<enumIndex public="1" set="method" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance `e`.

		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.

		If `e` is null, the result is unspecified.</haxe_doc>
		</enumIndex>
		<allEnums public="1" params="T" set="method" static="1">
			<f a="e">
				<x path="Enum"><c path="allEnums.T"/></x>
				<c path="Array"><c path="allEnums.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.

		This may return the empty Array `[]` if all constructors of `e` require
		arguments.

		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.

		If `e` is null, the result is unspecified.</haxe_doc>
		</allEnums>
		<haxe_doc>The Haxe Reflection API allows retrieval of type information at runtime.

	This class complements the more lightweight Reflect class, with a focus on
	class and enum instances.

	@see https://haxe.org/manual/types.html
	@see https://haxe.org/manual/std-reflection.html</haxe_doc>
	</class>
	<class path="geometryxd.AM" params="" file="./geometryxd/AM.hx">
		<positive_inside_I public="1" get="inline" set="null" line="13">
			<f a="a">
				<c path="Array"><x path="Int"/></c>
				<x path="Bool"/>
			</f>
			<haxe_doc>return true if incoming Int Array have at least one positive element
      @param a - incoming array</haxe_doc>
		</positive_inside_I>
		<zero_inside_I public="1" get="inline" set="null" line="21">
			<f a="a">
				<c path="Array"><x path="Int"/></c>
				<x path="Bool"/>
			</f>
			<haxe_doc>return true if incoming Int Array have at least one zero element
      @param a - incoming array</haxe_doc>
		</zero_inside_I>
		<negative_inside_I public="1" get="inline" set="null" line="29">
			<f a="a">
				<c path="Array"><x path="Int"/></c>
				<x path="Bool"/>
			</f>
			<haxe_doc>return true if incoming Int Array have at least one negative element
      @param a - incoming array</haxe_doc>
		</negative_inside_I>
		<positive_inside_F public="1" get="inline" set="null" line="37">
			<f a="a">
				<c path="Array"><x path="Float"/></c>
				<x path="Bool"/>
			</f>
			<haxe_doc>return true if incoming Float Array have at least one positive element
      @param a - incoming array</haxe_doc>
		</positive_inside_F>
		<zero_inside_F public="1" get="inline" set="null" line="45">
			<f a="a">
				<c path="Array"><x path="Float"/></c>
				<x path="Bool"/>
			</f>
			<haxe_doc>return true if incoming Float Array have at least one zero element
      @param a - incoming array</haxe_doc>
		</zero_inside_F>
		<negative_inside_F public="1" get="inline" set="null" line="54">
			<f a="a">
				<c path="Array"><x path="Float"/></c>
				<x path="Bool"/>
			</f>
			<haxe_doc>return true if incoming Float Array have at least one negative element
      @param a - incoming array</haxe_doc>
		</negative_inside_F>
		<same_size_I public="1" get="inline" set="null" line="63">
			<f a="a">
				<c path="Array"><c path="Array"><x path="Int"/></c></c>
				<x path="Null"><x path="Bool"/></x>
			</f>
			<haxe_doc>return true if Int Arrays have same size
      @param a - incoming arrays</haxe_doc>
		</same_size_I>
		<same_size_F public="1" get="inline" set="null" line="79">
			<f a="a">
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
				<x path="Null"><x path="Bool"/></x>
			</f>
			<haxe_doc>return true if Float Arrays have same size
      @param a - incoming arrays</haxe_doc>
		</same_size_F>
		<same_xI public="1" set="method" line="96">
			<f a="a">
				<c path="Array"><c path="Array"><x path="Int"/></c></c>
				<x path="Null"><x path="Bool"/></x>
			</f>
			<haxe_doc>compare Int Arrays. Returns true if all arrays have equal data
     @param a - incoming array field</haxe_doc>
		</same_xI>
		<same_xF public="1" set="method" line="114">
			<f a="a">
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
				<x path="Null"><x path="Bool"/></x>
			</f>
			<haxe_doc>compare Float Arrays. Returns true if all arrays have equal data
     @param a - incoming array field</haxe_doc>
		</same_xF>
		<sum_I public="1" get="inline" set="null" line="133">
			<f a="a">
				<c path="Array"><x path="Int"/></c>
				<x path="Null"><x path="Int"/></x>
			</f>
			<haxe_doc><![CDATA[returns sum of Int Array elements. [1,2,3] -> 6. tested
      @param a - incoming array]]></haxe_doc>
		</sum_I>
		<sum_F public="1" get="inline" set="null" line="143">
			<f a="a">
				<c path="Array"><x path="Float"/></c>
				<x path="Null"><x path="Float"/></x>
			</f>
			<haxe_doc><![CDATA[returns sum of Float Array elements. [1.1,2,3] -> 6.1. tested
      @param a - incoming array]]></haxe_doc>
		</sum_F>
		<diff_I public="1" set="method" line="153">
			<f a="a">
				<c path="Array"><x path="Int"/></c>
				<x path="Null"><x path="Int"/></x>
			</f>
			<haxe_doc><![CDATA[returns diff between first and others Int Array elements. [1,2,3] -> -4. tested
      @param a - incoming array]]></haxe_doc>
		</diff_I>
		<diff_F public="1" set="method" line="165">
			<f a="a">
				<c path="Array"><x path="Float"/></c>
				<x path="Null"><x path="Float"/></x>
			</f>
			<haxe_doc><![CDATA[returns diff between first and others Float Array elements. [1.1,2,3] -> -3.9. tested
      @param a - incoming array]]></haxe_doc>
		</diff_F>
		<middle_F public="1" set="method" line="177">
			<f a="a">
				<c path="Array"><x path="Float"/></c>
				<x path="Null"><x path="Float"/></x>
			</f>
			<haxe_doc>returns middle value of Float Array
      @param a - incoming array</haxe_doc>
		</middle_F>
		<multiply_I_I public="1" get="inline" set="null" line="188">
			<f a="a:n">
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<haxe_doc>multiplies each element of an Int Array by Int
      @param a - incoming array
      @param n - multiplier of each element</haxe_doc>
		</multiply_I_I>
		<multiply_F_F public="1" get="inline" set="null" line="202">
			<f a="a:n">
				<c path="Array"><x path="Float"/></c>
				<x path="Float"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>multiplies each element of an Float Array by Float
      @param a - incoming array
      @param n - multiplier of each element</haxe_doc>
		</multiply_F_F>
		<multiply_I public="1" get="inline" set="null" line="215">
			<f a="a">
				<c path="Array"><x path="Int"/></c>
				<x path="Null"><x path="Int"/></x>
			</f>
			<haxe_doc>multiplies all elements of an Int Array. [1, 2, 3] return 1 * 2 * 3
      @param a - incoming array</haxe_doc>
		</multiply_I>
		<multiply_F public="1" get="inline" set="null" line="227">
			<f a="a">
				<c path="Array"><x path="Float"/></c>
				<x path="Null"><x path="Float"/></x>
			</f>
			<haxe_doc>multiplies all elements of an Float Array. [1.1, 2.0, 3.0] return 1.1 * 2.0 * 3.0
      @param a - incoming array</haxe_doc>
		</multiply_F>
		<minus_I public="1" get="inline" set="null" line="239">
			<f a="a">
				<c path="Array"><x path="Int"/></c>
				<c path="Array"><x path="Int"/></c>
			</f>
			<haxe_doc>multiplies each element of the Int Array by -1
      @param a - incoming array</haxe_doc>
		</minus_I>
		<minus_F public="1" get="inline" set="null" line="246">
			<f a="a">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>multiplies each element of the Float Array by -1
      @param a - incoming array</haxe_doc>
		</minus_F>
		<sum_xI public="1" set="method" line="254">
			<f a="a">
				<c path="Array"><c path="Array"><x path="Int"/></c></c>
				<c path="Array"><x path="Int"/></c>
			</f>
			<haxe_doc>return Int Array which is Int Arrays sum. [[1, 2, 3], [-3, -2, -1]] return [-2, 0, 2]
      @param a - incoming arrays</haxe_doc>
		</sum_xI>
		<sum_xF public="1" set="method" line="263">
			<f a="a">
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>return Float Array which is Float Arrays sum. [[1.1, 2, 3], [-3, -2, -1]] return [-1.9, 0, 2]
      @param a - incoming arrays</haxe_doc>
		</sum_xF>
		<diff_xI public="1" set="method" line="272">
			<f a="a">
				<c path="Array"><c path="Array"><x path="Int"/></c></c>
				<c path="Array"><x path="Int"/></c>
			</f>
			<haxe_doc>return Int Array which is result of diff between first Int Array and others. [[1, 2, 3], [-3, -2, -1]] return [4, 4, 4]
      @param a - incoming arrays</haxe_doc>
		</diff_xI>
		<diff_xF public="1" set="method" line="281">
			<f a="a">
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>return Float Array which is result of diff between first Float Array and others. [[1.1, 2, 3], [-3, -2, -1]] return [4.1, 4, 4]
      @param a - incoming arrays</haxe_doc>
		</diff_xF>
		<middle_xF public="1" set="method" line="290">
			<f a="a">
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>return Float Array with middle values from arrays. [[1.1, 2, 3], [-3, -2, -1]] return [(1.1 - 3) / 2, (2 - 2) / 2, (3 - 1) / 2]
      @param a - incoming arrays</haxe_doc>
		</middle_xF>
		<multiply_xI_I public="1" set="method" line="300">
			<f a="a:n">
				<c path="Array"><c path="Array"><x path="Int"/></c></c>
				<x path="Int"/>
				<c path="Array"><c path="Array"><x path="Int"/></c></c>
			</f>
			<haxe_doc>return Int arrays which is result of multiplying each element by Int
      @param a - incoming arrays
      @param n - multiplier</haxe_doc>
		</multiply_xI_I>
		<multiply_xF_F public="1" set="method" line="313">
			<f a="a:n">
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
				<x path="Float"/>
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
			</f>
			<haxe_doc>return Float arrays which is result of multiplying each element by Float
      @param a - incoming arrays
      @param n - multiplier</haxe_doc>
		</multiply_xF_F>
		<multiply_xI public="1" set="method" line="325">
			<f a="a">
				<c path="Array"><c path="Array"><x path="Int"/></c></c>
				<c path="Array"><x path="Int"/></c>
			</f>
			<haxe_doc>return Int Array which is result of multiplying arrays. [[1, 2], [3, 4]] return [1 * 3, 2 * 4]
      @param a - incoming arrays</haxe_doc>
		</multiply_xI>
		<multiply_xF public="1" set="method" line="340">
			<f a="a">
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>return Float Array which is result of multiplying arrays. [[3.1, 2], [3, 4]] return [3.1 * 3, 2 * 4]
      @param a - incoming arrays</haxe_doc>
		</multiply_xF>
		<multisum_xI public="1" set="method" line="355">
			<f a="a">
				<c path="Array"><c path="Array"><x path="Int"/></c></c>
				<x path="Null"><x path="Int"/></x>
			</f>
			<haxe_doc>Int Arrays bonus function. Short form of sum_I(multiply_xI(a)). [[a, b], [c, d]] return a * c + b * d
      @param a - incoming arrays</haxe_doc>
		</multisum_xI>
		<multisum_xF public="1" set="method" line="370">
			<f a="a">
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
				<x path="Null"><x path="Float"/></x>
			</f>
			<haxe_doc>Float Arrays bonus function. Short form of sum_F(multiply_xF(a)). [[a, b], [c, d]] return a * c + b * d
      @param a - incoming arrays</haxe_doc>
		</multisum_xF>
		<sum_previous_I public="1" get="inline" set="null" line="385">
			<f a="a">
				<c path="Array"><x path="Int"/></c>
				<c path="Array"><x path="Int"/></c>
			</f>
			<haxe_doc>return Int Array which is result of sum with previous element. [1, 2, 3] return [1, 3, 5]
      @param a - incoming array</haxe_doc>
		</sum_previous_I>
		<diff_previous_I public="1" get="inline" set="null" line="395">
			<f a="a">
				<c path="Array"><x path="Int"/></c>
				<c path="Array"><x path="Int"/></c>
			</f>
			<haxe_doc>return Int Array which is result of diff with previous element. [1, 2, 3] return [1, 1, 1]
      @param a - incoming array</haxe_doc>
		</diff_previous_I>
		<sum_before_I public="1" get="inline" set="null" line="405">
			<f a="a">
				<c path="Array"><x path="Int"/></c>
				<c path="Array"><x path="Int"/></c>
			</f>
			<haxe_doc>return Int Array which is result of sum each element with before elements sum. [1, 2, 3] return [1, 3, 6]
      @param a - incoming array</haxe_doc>
		</sum_before_I>
		<diff_before_I public="1" get="inline" set="null" line="419">
			<f a="a">
				<c path="Array"><x path="Int"/></c>
				<c path="Array"><x path="Int"/></c>
			</f>
			<haxe_doc>return Int Array which is result of diff each element with before elements diff. [1, 2, 3] return [1, 1, 2]
      @param a - incoming array</haxe_doc>
		</diff_before_I>
		<sum_previous_F public="1" get="inline" set="null" line="433">
			<f a="a">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>return Float Array which is result of sum with previous element. [1.1, 2, 3] return [1.1, 3.1, 5]
      @param a - incoming array</haxe_doc>
		</sum_previous_F>
		<diff_previous_F public="1" get="inline" set="null" line="443">
			<f a="a">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>return Float Array which is result of diff with previous element. [1.1, 2, 3] return [1.1, 0.9, 1]
      @param a - incoming array</haxe_doc>
		</diff_previous_F>
		<sum_before_F public="1" get="inline" set="null" line="453">
			<f a="a">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>return Float Array which is result of sum each element with before elements sum. [1.1, 2, 3] return [1.1, 3.1, 6.1]
      @param a - incoming array</haxe_doc>
		</sum_before_F>
		<diff_before_F public="1" get="inline" set="null" line="467">
			<f a="a">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>return Float Array which is result of diff each element with before elements diff. [1.1, 2, 3] return [1.1, 0.9, 2.1]
      @param a - incoming array</haxe_doc>
		</diff_before_F>
		<recounter_I_F public="1" get="inline" set="null" line="482">
			<f a="what">
				<c path="Array"><x path="Int"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>recount Int Array to Float Array
     @param what - incoming array</haxe_doc>
		</recounter_I_F>
		<recounter_F_I public="1" get="inline" set="null" line="491">
			<f a="what">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Int"/></c>
			</f>
			<haxe_doc>recount Float Array to Int Array
     @param what - incoming array</haxe_doc>
		</recounter_F_I>
		<recounter_I_S public="1" get="inline" set="null" line="500">
			<f a="what">
				<c path="Array"><x path="Int"/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>recount Int Array to String Array
     @param what - incoming array</haxe_doc>
		</recounter_I_S>
		<recounter_F_S public="1" get="inline" set="null" line="509">
			<f a="what">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>recount Float Array to String Array
     @param what - incoming array</haxe_doc>
		</recounter_F_S>
		<recounter_S_I public="1" get="inline" set="null" line="518">
			<f a="what">
				<c path="Array"><c path="String"/></c>
				<c path="Array"><x path="Int"/></c>
			</f>
			<haxe_doc>recount String Array to Int Array
     @param what - incoming array</haxe_doc>
		</recounter_S_I>
		<recounter_S_F public="1" get="inline" set="null" line="527">
			<f a="what">
				<c path="Array"><c path="String"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>recount String Array to Float Array
     @param what - incoming array</haxe_doc>
		</recounter_S_F>
		<repeater_F_F public="1" get="inline" set="null" line="539">
			<f a="n:what:?full" v="::false">
				<x path="Int"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Bool"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":value"><e>{ full : false }</e></m></meta>
			<haxe_doc>repeat Float Array to specified length
     @param n - result array length
     @param what - incoming array
     @param full - if true then result array will be not cutted to result array length parameter</haxe_doc>
		</repeater_F_F>
		<repeater_I_I public="1" get="inline" set="null" line="561">
			<f a="n:what:?full" v="::false">
				<x path="Int"/>
				<c path="Array"><x path="Int"/></c>
				<x path="Bool"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<meta><m n=":value"><e>{ full : false }</e></m></meta>
			<haxe_doc>repeat Int Array to specified length
     @param n - result array length
     @param what - incoming array
     @param full - if true then result array will be not cutted to result array length parameter</haxe_doc>
		</repeater_I_I>
		<repeater_S_S public="1" get="inline" set="null" line="583">
			<f a="n:what:?full" v="::false">
				<x path="Int"/>
				<c path="Array"><c path="String"/></c>
				<x path="Bool"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":value"><e>{ full : false }</e></m></meta>
			<haxe_doc>repeat String Array to specified length
     @param n - result array length
     @param what - incoming array
     @param full - if true then result array will be not cutted to result array length parameter</haxe_doc>
		</repeater_S_S>
		<repeater_F_I public="1" set="method" line="605">
			<f a="n:what_:?full" v="::false">
				<x path="Int"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Bool"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<meta><m n=":value"><e>{ full : false }</e></m></meta>
			<haxe_doc>repeat Float Array to specified length Int Array
     @param n - result array length
     @param what - incoming array
     @param full - if true then result array will be not cutted to result array length parameter</haxe_doc>
		</repeater_F_I>
		<repeater_S_I public="1" set="method" line="628">
			<f a="n:what_:?full" v="::false">
				<x path="Int"/>
				<c path="Array"><c path="String"/></c>
				<x path="Bool"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<meta><m n=":value"><e>{ full : false }</e></m></meta>
			<haxe_doc>repeat String Array to specified length Int Array
     @param n - result array length
     @param what - incoming array
     @param full - if true then result array will be not cutted to result array length parameter</haxe_doc>
		</repeater_S_I>
		<repeater_I_F public="1" set="method" line="651">
			<f a="n:what_:?full" v="::false">
				<x path="Int"/>
				<c path="Array"><x path="Int"/></c>
				<x path="Bool"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":value"><e>{ full : false }</e></m></meta>
			<haxe_doc>repeat Int Array to specified length Float Array
     @param n - result array length
     @param what - incoming array
     @param full - if true then result array will be not cutted to result array length parameter</haxe_doc>
		</repeater_I_F>
		<repeater_S_F public="1" set="method" line="674">
			<f a="n:what_:?full" v="::false">
				<x path="Int"/>
				<c path="Array"><c path="String"/></c>
				<x path="Bool"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":value"><e>{ full : false }</e></m></meta>
			<haxe_doc>repeat String Array to specified length Float Array
     @param n - result array length
     @param what - incoming array
     @param full - if true then result array will be not cutted to result array length parameter</haxe_doc>
		</repeater_S_F>
		<repeater_I_S public="1" set="method" line="697">
			<f a="n:what_:?full" v="::false">
				<x path="Int"/>
				<c path="Array"><x path="Int"/></c>
				<x path="Bool"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":value"><e>{ full : false }</e></m></meta>
			<haxe_doc>repeat Int Array to specified length String Array
     @param n - result array length
     @param what - incoming array
     @param full - if true then result array will be not cutted to result array length parameter</haxe_doc>
		</repeater_I_S>
		<repeater_F_S public="1" set="method" line="720">
			<f a="n:what_:?full" v="::false">
				<x path="Int"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Bool"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":value"><e>{ full : false }</e></m></meta>
			<haxe_doc>repeat Float Array to specified length String Array
     @param n - result array length
     @param what - incoming array
     @param full - if true then result array will be not cutted to result array length parameter</haxe_doc>
		</repeater_F_S>
		<an_in_b_S public="1" get="inline" set="null" line="744">
			<f a="a:b">
				<c path="Array"><c path="String"/></c>
				<c path="Array"><c path="String"/></c>
				<c path="Array"><c path="Array"><x path="Int"/></c></c>
			</f>
			<haxe_doc>return array of arrays with pair indexes which is indexes equivalent elements of a and b arrays.
     a=["1", "2"] b=["1", "2", "1"] return [[0, 0], [0, 2], [1, 1]]
     @param a - array what find
     @param b - array where find</haxe_doc>
		</an_in_b_S>
		<an_in_bn_S public="1" get="inline" set="null" line="764">
			<f a="a:b">
				<c path="Array"><c path="String"/></c>
				<c path="Array"><c path="Array"><c path="String"/></c></c>
				<c path="Array"><c path="Array"><x path="Int"/></c></c>
			</f>
			<haxe_doc>return array of arrays with pair indexes which is indexes equivalent elements of a and b arrays.
     a=["1", "2"] b=[["1", "2", "1"],["0", "2"]] return [[0, 0, 0], [0, 0, 2], [1, 0, 1], [1, 1, 1]]. where indexes [1, 0, 1] = [1(a), 0(b), 1(b[0])]
     @param a - array what find
     @param b - array where find</haxe_doc>
		</an_in_bn_S>
		<an_in_b_I public="1" get="inline" set="null" line="786">
			<f a="a:b">
				<c path="Array"><x path="Int"/></c>
				<c path="Array"><x path="Int"/></c>
				<c path="Array"><c path="Array"><x path="Int"/></c></c>
			</f>
			<haxe_doc>return array of arrays with pair indexes which is indexes equivalent elements of a and b arrays.
     a=[1, 2] b=[1, 2, 1] return [[0, 0], [0, 2], [1, 1]]
     @param a - array what find
     @param b - array where find</haxe_doc>
		</an_in_b_I>
		<an_in_bn_I public="1" get="inline" set="null" line="806">
			<f a="a:b">
				<c path="Array"><x path="Int"/></c>
				<c path="Array"><c path="Array"><x path="Int"/></c></c>
				<c path="Array"><c path="Array"><x path="Int"/></c></c>
			</f>
			<haxe_doc>return array of arrays with pair indexes which is indexes equivalent elements of a and b arrays.
     a=[1, 2] b=[[1, 2, 1],[0, 2]] return [[0, 0, 0], [0, 0, 2], [1, 0, 1], [1, 1, 1]]. where indexes [1, 0, 1] = [1(a), 0(b), 1(b[0])]
     @param a - array what find
     @param b - array where find</haxe_doc>
		</an_in_bn_I>
		<an_in_b_F public="1" get="inline" set="null" line="828">
			<f a="a:b">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><c path="Array"><x path="Int"/></c></c>
			</f>
			<haxe_doc>return array of arrays with pair indexes which is indexes equivalent elements of a and b arrays.
     a=[1.0, 2.0] b=[1.0, 2.0, 1.0] return [[0, 0], [0, 2], [1, 1]]
     @param a - array what find
     @param b - array where find</haxe_doc>
		</an_in_b_F>
		<an_in_bn_F public="1" get="inline" set="null" line="848">
			<f a="a:b">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
				<c path="Array"><c path="Array"><x path="Int"/></c></c>
			</f>
			<haxe_doc>return array of arrays with pair indexes which is indexes equivalent elements of a and b arrays.
     a=[1.0, 2.0] b=[[1.0, 2.0, 1.0],[0, 2.0]] return [[0, 0, 0], [0, 0, 2], [1, 0, 1], [1, 1, 1]]. where indexes [1, 0, 1] = [1(a), 0(b), 1(b[0])]
     @param a - array what find
     @param b - array where find</haxe_doc>
		</an_in_bn_F>
		<chain_indexes public="1" set="method" line="874">
			<f a="a_l:n:ring">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="Array"><c path="Array"><x path="Int"/></c></c>
			</f>
			<haxe_doc>chain bonus function. split range to sequences specified length n with same border values.
     f(6, 3, false) return [[0, 1, 2], [2, 3, 4]]. But f(6, 3, true) return [[0, 1, 2], [2, 3, 4], [4, 5, 0]].
     Can be used to split dotsXDfield (array of 3D dots) to array of separated 4dots curves trajectories which have same border dots.
     Just split array of dots length a_l to n = 4. Then recount to beziercurves or create multidot curve use each last three dots.
     @param a_l - range of indexes (length of array which will be used later as splitted)
     @param n - length of each sequence (chain link)
     @param ring - if true then 0 will be added at the end of range of indexes, for the case of strict coincidence</haxe_doc>
		</chain_indexes>
		<chain_S public="1" get="inline" set="null" line="897">
			<f a="a:n:?ring" v="::false">
				<c path="Array"><c path="String"/></c>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="Array"><c path="Array"><c path="String"/></c></c>
			</f>
			<meta><m n=":value"><e>{ ring : false }</e></m></meta>
			<haxe_doc>create chain from String Array. Sequences with same border values
     @param a - incoming array
     @param n - chain link length
     @param ring - if true then first incoming element will be added at the end of range, for the case of strict coincidence</haxe_doc>
		</chain_S>
		<chain_I public="1" get="inline" set="null" line="915">
			<f a="a:n:?ring" v="::false">
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="Array"><c path="Array"><x path="Int"/></c></c>
			</f>
			<meta><m n=":value"><e>{ ring : false }</e></m></meta>
			<haxe_doc>create chain from Int Array. Sequences with same border values
     @param a - incoming array
     @param n - chain link length
     @param ring - if true then first incoming element will be added at the end of range, for the case of strict coincidence</haxe_doc>
		</chain_I>
		<chain_F public="1" get="inline" set="null" line="933">
			<f a="a:n:?ring" v="::false">
				<c path="Array"><x path="Float"/></c>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
			</f>
			<meta><m n=":value"><e>{ ring : false }</e></m></meta>
			<haxe_doc>create chain from Float Array. Sequences with same border values
     @param a - incoming array
     @param n - chain link length
     @param ring - if true then first incoming element will be added at the end of range, for the case of strict coincidence</haxe_doc>
		</chain_F>
		<maxabs public="1" set="method" line="951">
			<f a="a">
				<c path="Array"><x path="Float"/></c>
				<x path="Float"/>
			</f>
			<haxe_doc>return Float Array element with maximum absolute value with sign.
     Each element compared as abs(element). [1, 2, -4] return -4.
     @param a - incoming array</haxe_doc>
		</maxabs>
		<new public="1" set="method" line="7"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* array manipulation</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="geometryxd.AngleUnit" params="" file="./geometryxd/Angle.hx" module="geometryxd.Angle">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="geometryxd._Angle.AngleUnit_Impl_" params="" file="./geometryxd/Angle.hx" private="1" module="geometryxd.Angle" extern="1">
	<None public="1" get="inline" set="null" expr="cast 0" line="4" static="1">
		<x path="geometryxd.AngleUnit"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</None>
	<Turn public="1" get="inline" set="null" expr="cast 1" line="5" static="1">
		<x path="geometryxd.AngleUnit"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Turn>
	<Mulp public="1" get="inline" set="null" expr="cast 2" line="6" static="1">
		<x path="geometryxd.AngleUnit"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Mulp>
	<Quad public="1" get="inline" set="null" expr="cast 3" line="7" static="1">
		<x path="geometryxd.AngleUnit"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Quad>
	<Sext public="1" get="inline" set="null" expr="cast 4" line="8" static="1">
		<x path="geometryxd.AngleUnit"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Sext>
	<Rad public="1" get="inline" set="null" expr="cast 5" line="9" static="1">
		<x path="geometryxd.AngleUnit"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Rad>
	<Hexa public="1" get="inline" set="null" expr="cast 6" line="10" static="1">
		<x path="geometryxd.AngleUnit"/>
		<meta>
			<m n=":value"><e>cast 6</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Hexa>
	<Bdeg public="1" get="inline" set="null" expr="cast 7" line="11" static="1">
		<x path="geometryxd.AngleUnit"/>
		<meta>
			<m n=":value"><e>cast 7</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Bdeg>
	<Deg public="1" get="inline" set="null" expr="cast 8" line="12" static="1">
		<x path="geometryxd.AngleUnit"/>
		<meta>
			<m n=":value"><e>cast 8</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Deg>
	<Grad public="1" get="inline" set="null" expr="cast 9" line="13" static="1">
		<x path="geometryxd.AngleUnit"/>
		<meta>
			<m n=":value"><e>cast 9</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Grad>
	<Marc public="1" get="inline" set="null" expr="cast 10" line="14" static="1">
		<x path="geometryxd.AngleUnit"/>
		<meta>
			<m n=":value"><e>cast 10</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Marc>
	<Sarc public="1" get="inline" set="null" expr="cast 11" line="15" static="1">
		<x path="geometryxd.AngleUnit"/>
		<meta>
			<m n=":value"><e>cast 11</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Sarc>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="geometryxd._Angle.AngleUnit_Impl_" params="" file="./geometryxd/Angle.hx" private="1" module="geometryxd.Angle" extern="1">
		<None public="1" get="inline" set="null" expr="cast 0" line="4" static="1">
			<x path="geometryxd.AngleUnit"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</None>
		<Turn public="1" get="inline" set="null" expr="cast 1" line="5" static="1">
			<x path="geometryxd.AngleUnit"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Turn>
		<Mulp public="1" get="inline" set="null" expr="cast 2" line="6" static="1">
			<x path="geometryxd.AngleUnit"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Mulp>
		<Quad public="1" get="inline" set="null" expr="cast 3" line="7" static="1">
			<x path="geometryxd.AngleUnit"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Quad>
		<Sext public="1" get="inline" set="null" expr="cast 4" line="8" static="1">
			<x path="geometryxd.AngleUnit"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Sext>
		<Rad public="1" get="inline" set="null" expr="cast 5" line="9" static="1">
			<x path="geometryxd.AngleUnit"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Rad>
		<Hexa public="1" get="inline" set="null" expr="cast 6" line="10" static="1">
			<x path="geometryxd.AngleUnit"/>
			<meta>
				<m n=":value"><e>cast 6</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Hexa>
		<Bdeg public="1" get="inline" set="null" expr="cast 7" line="11" static="1">
			<x path="geometryxd.AngleUnit"/>
			<meta>
				<m n=":value"><e>cast 7</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Bdeg>
		<Deg public="1" get="inline" set="null" expr="cast 8" line="12" static="1">
			<x path="geometryxd.AngleUnit"/>
			<meta>
				<m n=":value"><e>cast 8</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Deg>
		<Grad public="1" get="inline" set="null" expr="cast 9" line="13" static="1">
			<x path="geometryxd.AngleUnit"/>
			<meta>
				<m n=":value"><e>cast 9</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Grad>
		<Marc public="1" get="inline" set="null" expr="cast 10" line="14" static="1">
			<x path="geometryxd.AngleUnit"/>
			<meta>
				<m n=":value"><e>cast 10</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Marc>
		<Sarc public="1" get="inline" set="null" expr="cast 11" line="15" static="1">
			<x path="geometryxd.AngleUnit"/>
			<meta>
				<m n=":value"><e>cast 11</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Sarc>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="geometryxd.Angle" params="" file="./geometryxd/Angle.hx">
		<value>
			<x path="Float"/>
			<haxe_doc>* internal storage for base angle value, which unit is `turn`. 1 `turn` is 360 `deg` is one full rotation.
     * Alternative `turn` names is `cyc`(circle), `rev`(revolution), `rot`(complete rotation)</haxe_doc>
		</value>
		<geo expr="new GeometryXD(false)">
			<c path="geometryxd.GeometryXD"/>
			<meta><m n=":value"><e>new GeometryXD(false)</e></m></meta>
			<haxe_doc>* internal usage of methods</haxe_doc>
		</geo>
		<useAngle public="1" set="method" line="89">
			<f a="angle">
				<c path="geometryxd.Angle"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* set angle value.
     * @param angle incoming Angle object</haxe_doc>
		</useAngle>
		<useTurn public="1" set="method" line="97">
			<f a="value">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* set angle value. Incoming parameter angular unit is `turn`
     * @param value of angle</haxe_doc>
		</useTurn>
		<useMulp public="1" set="method" line="105">
			<f a="value">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* set angle value. Incoming parameter angular unit is `multiples of Math.PI`
     * @param value of angle</haxe_doc>
		</useMulp>
		<useQuad public="1" set="method" line="113">
			<f a="value">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* set angle value. Incoming parameter angular unit is `quadrant`
     * @param value of angle</haxe_doc>
		</useQuad>
		<useSext public="1" set="method" line="121">
			<f a="value">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* set angle value. Incoming parameter angular unit is `sextant`
     * @param value of angle</haxe_doc>
		</useSext>
		<useRad public="1" set="method" line="129">
			<f a="value">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* set angle value. Incoming parameter angular unit is `radian`
     * @param value of angle</haxe_doc>
		</useRad>
		<useHexa public="1" set="method" line="137">
			<f a="value">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* set angle value. Incoming parameter angular unit is `hexacontade`
     * @param value of angle</haxe_doc>
		</useHexa>
		<useBdeg public="1" set="method" line="145">
			<f a="value">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* set angle value. Incoming parameter angular unit is `binary degree`
     * @param value of angle</haxe_doc>
		</useBdeg>
		<useDeg public="1" set="method" line="153">
			<f a="value">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* set angle value. Incoming parameter angular unit is `degree`
     * @param value of angle</haxe_doc>
		</useDeg>
		<useGrad public="1" set="method" line="161">
			<f a="value">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* set angle value. Incoming parameter angular unit is `grad`
     * @param value of angle</haxe_doc>
		</useGrad>
		<useMarc public="1" set="method" line="169">
			<f a="value">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* set angle value. Incoming parameter angular unit is `minute of arc`
     * @param value of angle</haxe_doc>
		</useMarc>
		<useSarc public="1" set="method" line="177">
			<f a="value">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* set angle value. Incoming parameter angular unit is `second of arc`
     * @param value of angle</haxe_doc>
		</useSarc>
		<turn public="1" set="method" line="186">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* get angle value as `turn`</haxe_doc>
		</turn>
		<mulp public="1" set="method" line="193">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* get angle value as `multiples of Math.PI`</haxe_doc>
		</mulp>
		<quad public="1" set="method" line="200">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* get angle value as `quadrant`</haxe_doc>
		</quad>
		<sext public="1" set="method" line="207">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* get angle value as `sextant`</haxe_doc>
		</sext>
		<rad public="1" set="method" line="214">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* get angle value as `radian`</haxe_doc>
		</rad>
		<hexa public="1" set="method" line="221">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* get angle value as `hexacontade`</haxe_doc>
		</hexa>
		<bdeg public="1" set="method" line="228">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* get angle value as `binary degree`</haxe_doc>
		</bdeg>
		<deg public="1" set="method" line="235">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* get angle value as `degree`</haxe_doc>
		</deg>
		<grad public="1" set="method" line="242">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* get angle value as `grad`</haxe_doc>
		</grad>
		<marc public="1" set="method" line="249">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* get angle value as `minute of arc`</haxe_doc>
		</marc>
		<sarc public="1" set="method" line="256">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* get angle value as `second of arc`</haxe_doc>
		</sarc>
		<sin public="1" set="method" line="262">
			<f a=""><x path="Float"/></f>
			<haxe_doc>trigonometric sine of angle</haxe_doc>
		</sin>
		<cos public="1" set="method" line="264">
			<f a=""><x path="Float"/></f>
			<haxe_doc>trigonometric cosine of angle</haxe_doc>
		</cos>
		<tan public="1" set="method" line="266">
			<f a=""><x path="Float"/></f>
			<haxe_doc>trigonometric tangent of angle</haxe_doc>
		</tan>
		<cot public="1" set="method" line="268">
			<f a=""><x path="Float"/></f>
			<haxe_doc>trigonometric cotangent of angle</haxe_doc>
		</cot>
		<sec public="1" set="method" line="270">
			<f a=""><x path="Float"/></f>
			<haxe_doc>trigonometric secant of angle</haxe_doc>
		</sec>
		<csc public="1" set="method" line="272">
			<f a=""><x path="Float"/></f>
			<haxe_doc>trigonometric cosecant of angle</haxe_doc>
		</csc>
		<sinh public="1" set="method" line="275">
			<f a=""><x path="Float"/></f>
			<haxe_doc>hyperbolic sine of angle</haxe_doc>
		</sinh>
		<cosh public="1" set="method" line="277">
			<f a=""><x path="Float"/></f>
			<haxe_doc>hyperbolic cosine of angle</haxe_doc>
		</cosh>
		<tanh public="1" set="method" line="279">
			<f a=""><x path="Float"/></f>
			<haxe_doc>hyperbolic tangent of angle</haxe_doc>
		</tanh>
		<coth public="1" set="method" line="281">
			<f a=""><x path="Float"/></f>
			<haxe_doc>hyperbolic cotangent of angle</haxe_doc>
		</coth>
		<sech public="1" set="method" line="283">
			<f a=""><x path="Float"/></f>
			<haxe_doc>hyperbolic secant of angle</haxe_doc>
		</sech>
		<csch public="1" set="method" line="285">
			<f a=""><x path="Float"/></f>
			<haxe_doc>hyperbolic cosecant of angle</haxe_doc>
		</csch>
		<useSin public="1" set="method" line="292">
			<f a="v">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>set angle value using trigonometric sine of angle 
     * @param v sine of angle</haxe_doc>
		</useSin>
		<useCos public="1" set="method" line="296">
			<f a="v">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>set angle value using trigonometric cosine of angle 
     * @param v cosine of angle</haxe_doc>
		</useCos>
		<useTan public="1" set="method" line="300">
			<f a="v">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>set angle value using trigonometric tangent of angle 
     * @param v tangent of angle</haxe_doc>
		</useTan>
		<useCot public="1" set="method" line="304">
			<f a="v">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>set angle value using trigonometric cotangent of angle 
     * @param v cotangent of angle</haxe_doc>
		</useCot>
		<useSec public="1" set="method" line="308">
			<f a="v">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>set angle value using trigonometric secant of angle 
     * @param v secant of angle</haxe_doc>
		</useSec>
		<useCsc public="1" set="method" line="312">
			<f a="v">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>set angle value using trigonometric cosecant of angle 
     * @param v cosecant of angle</haxe_doc>
		</useCsc>
		<useSinh public="1" set="method" line="317">
			<f a="v">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>set angle value using hyperbolic sine of angle 
     * @param v sine of angle</haxe_doc>
		</useSinh>
		<useCosh public="1" set="method" line="321">
			<f a="v">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>set angle value using hyperbolic cosine of angle 
     * @param v cosine of angle</haxe_doc>
		</useCosh>
		<useTanh public="1" set="method" line="325">
			<f a="v">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>set angle value using hyperbolic tangent of angle 
     * @param v tangent of angle</haxe_doc>
		</useTanh>
		<useCoth public="1" set="method" line="329">
			<f a="v">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>set angle value using hyperbolic cotangent of angle 
     * @param v cotangent of angle</haxe_doc>
		</useCoth>
		<useSech public="1" set="method" line="333">
			<f a="v">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>set angle value using hyperbolic secant of angle 
     * @param v secant of angle</haxe_doc>
		</useSech>
		<useCsch public="1" set="method" line="337">
			<f a="v">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>set angle value using hyperbolic cosecant of angle 
     * @param v cosecant of angle</haxe_doc>
		</useCsch>
		<fromSin public="1" set="method" line="345">
			<f a="v">
				<x path="Float"/>
				<c path="geometryxd.Angle"/>
			</f>
			<haxe_doc>new Angle object from trigonometric sine of angle 
     * @param v sine of angle</haxe_doc>
		</fromSin>
		<fromCos public="1" set="method" line="349">
			<f a="v">
				<x path="Float"/>
				<c path="geometryxd.Angle"/>
			</f>
			<haxe_doc>new Angle object from trigonometric cosine of angle 
     * @param v cosine of angle</haxe_doc>
		</fromCos>
		<fromTan public="1" set="method" line="353">
			<f a="v">
				<x path="Float"/>
				<c path="geometryxd.Angle"/>
			</f>
			<haxe_doc>new Angle object from trigonometric tangent of angle 
     * @param v tangent of angle</haxe_doc>
		</fromTan>
		<fromCot public="1" set="method" line="357">
			<f a="v">
				<x path="Float"/>
				<c path="geometryxd.Angle"/>
			</f>
			<haxe_doc>new Angle object from trigonometric cotangent of angle 
     * @param v cotangent of angle</haxe_doc>
		</fromCot>
		<fromSec public="1" set="method" line="361">
			<f a="v">
				<x path="Float"/>
				<c path="geometryxd.Angle"/>
			</f>
			<haxe_doc>new Angle object from trigonometric secant of angle 
     * @param v secant of angle</haxe_doc>
		</fromSec>
		<fromCsc public="1" set="method" line="365">
			<f a="v">
				<x path="Float"/>
				<c path="geometryxd.Angle"/>
			</f>
			<haxe_doc>new Angle object from trigonometric cosecant of angle 
     * @param v cosecant of angle</haxe_doc>
		</fromCsc>
		<fromSinh public="1" set="method" line="370">
			<f a="v">
				<x path="Float"/>
				<c path="geometryxd.Angle"/>
			</f>
			<haxe_doc>new Angle object from hyperbolic sine of angle 
     * @param v sine of angle</haxe_doc>
		</fromSinh>
		<fromCosh public="1" set="method" line="374">
			<f a="v">
				<x path="Float"/>
				<c path="geometryxd.Angle"/>
			</f>
			<haxe_doc>new Angle object from hyperbolic cosine of angle 
     * @param v cosine of angle</haxe_doc>
		</fromCosh>
		<fromTanh public="1" set="method" line="378">
			<f a="v">
				<x path="Float"/>
				<c path="geometryxd.Angle"/>
			</f>
			<haxe_doc>new Angle object from hyperbolic tangent of angle 
     * @param v tangent of angle</haxe_doc>
		</fromTanh>
		<fromCoth public="1" set="method" line="382">
			<f a="v">
				<x path="Float"/>
				<c path="geometryxd.Angle"/>
			</f>
			<haxe_doc>new Angle object from hyperbolic cotangent of angle 
     * @param v cotangent of angle</haxe_doc>
		</fromCoth>
		<fromSech public="1" set="method" line="386">
			<f a="v">
				<x path="Float"/>
				<c path="geometryxd.Angle"/>
			</f>
			<haxe_doc>new Angle object from hyperbolic secant of angle 
     * @param v secant of angle</haxe_doc>
		</fromSech>
		<fromCsch public="1" set="method" line="390">
			<f a="v">
				<x path="Float"/>
				<c path="geometryxd.Angle"/>
			</f>
			<haxe_doc>new Angle object from hyperbolic cosecant of angle 
     * @param v cosecant of angle</haxe_doc>
		</fromCsch>
		<fromAngle public="1" set="method" line="399">
			<f a="angle">
				<c path="geometryxd.Angle"/>
				<c path="geometryxd.Angle"/>
			</f>
			<haxe_doc>* new angle object using incoming angle object
     * @param value of angle</haxe_doc>
		</fromAngle>
		<fromTurn public="1" set="method" line="405">
			<f a="value">
				<x path="Float"/>
				<c path="geometryxd.Angle"/>
			</f>
			<haxe_doc>* new angle object. Incoming parameter angular unit is `turn`
     * @param value of angle</haxe_doc>
		</fromTurn>
		<fromMulp public="1" set="method" line="411">
			<f a="value">
				<x path="Float"/>
				<c path="geometryxd.Angle"/>
			</f>
			<haxe_doc>* new angle object. Incoming parameter angular unit is `multiples of Math.PI`
     * @param value of angle</haxe_doc>
		</fromMulp>
		<fromQuad public="1" set="method" line="417">
			<f a="value">
				<x path="Float"/>
				<c path="geometryxd.Angle"/>
			</f>
			<haxe_doc>* new angle object. Incoming parameter angular unit is `quadrant`
     * @param value of angle</haxe_doc>
		</fromQuad>
		<fromSext public="1" set="method" line="423">
			<f a="value">
				<x path="Float"/>
				<c path="geometryxd.Angle"/>
			</f>
			<haxe_doc>* new angle object. Incoming parameter angular unit is `sextant`
     * @param value of angle</haxe_doc>
		</fromSext>
		<fromRad public="1" set="method" line="429">
			<f a="value">
				<x path="Float"/>
				<c path="geometryxd.Angle"/>
			</f>
			<haxe_doc>* new angle object. Incoming parameter angular unit is `radian`
     * @param value of angle</haxe_doc>
		</fromRad>
		<fromHexa public="1" set="method" line="435">
			<f a="value">
				<x path="Float"/>
				<c path="geometryxd.Angle"/>
			</f>
			<haxe_doc>* new angle object. Incoming parameter angular unit is `hexacontade`
     * @param value of angle</haxe_doc>
		</fromHexa>
		<fromBdeg public="1" set="method" line="441">
			<f a="value">
				<x path="Float"/>
				<c path="geometryxd.Angle"/>
			</f>
			<haxe_doc>* new angle object. Incoming parameter angular unit is `binary degree`
     * @param value of angle</haxe_doc>
		</fromBdeg>
		<fromDeg public="1" set="method" line="447">
			<f a="value">
				<x path="Float"/>
				<c path="geometryxd.Angle"/>
			</f>
			<haxe_doc>* new angle object. Incoming parameter angular unit is `degree`
     * @param value of angle</haxe_doc>
		</fromDeg>
		<fromGrad public="1" set="method" line="453">
			<f a="value">
				<x path="Float"/>
				<c path="geometryxd.Angle"/>
			</f>
			<haxe_doc>* new angle object. Incoming parameter angular unit is `grad`
     * @param value of angle</haxe_doc>
		</fromGrad>
		<fromMarc public="1" set="method" line="459">
			<f a="value">
				<x path="Float"/>
				<c path="geometryxd.Angle"/>
			</f>
			<haxe_doc>* new angle object. Incoming parameter angular unit is `minute of arc`
     * @param value of angle</haxe_doc>
		</fromMarc>
		<fromSarc public="1" set="method" line="465">
			<f a="value">
				<x path="Float"/>
				<c path="geometryxd.Angle"/>
			</f>
			<haxe_doc>* new angle object. Incoming parameter angular unit is `second of arc`
     * @param value of angle</haxe_doc>
		</fromSarc>
		<addTurn public="1" set="method" line="474">
			<f a="value">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* add value to angle object. Incoming parameter angular unit is `turn`
     * @param value of angle</haxe_doc>
		</addTurn>
		<addMulp public="1" set="method" line="480">
			<f a="value">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* add value to angle object. Incoming parameter angular unit is `multiples of Math.PI`
     * @param value of angle</haxe_doc>
		</addMulp>
		<addQuad public="1" set="method" line="486">
			<f a="value">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* add value to angle object. Incoming parameter angular unit is `quadrant`
     * @param value of angle</haxe_doc>
		</addQuad>
		<addSext public="1" set="method" line="492">
			<f a="value">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* add value to angle object. Incoming parameter angular unit is `sextant`
     * @param value of angle</haxe_doc>
		</addSext>
		<addRad public="1" set="method" line="498">
			<f a="value">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* add value to angle object. Incoming parameter angular unit is `radian`
     * @param value of angle</haxe_doc>
		</addRad>
		<addHexa public="1" set="method" line="504">
			<f a="value">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* add value to angle object. Incoming parameter angular unit is `hexacontade`
     * @param value of angle</haxe_doc>
		</addHexa>
		<addBdeg public="1" set="method" line="510">
			<f a="value">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* add value to angle object. Incoming parameter angular unit is `binary degree`
     * @param value of angle</haxe_doc>
		</addBdeg>
		<addDeg public="1" set="method" line="516">
			<f a="value">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* add value to angle object. Incoming parameter angular unit is `degree`
     * @param value of angle</haxe_doc>
		</addDeg>
		<addGrad public="1" set="method" line="522">
			<f a="value">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* add value to angle object. Incoming parameter angular unit is `grad`
     * @param value of angle</haxe_doc>
		</addGrad>
		<addMarc public="1" set="method" line="528">
			<f a="value">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* add value to angle object. Incoming parameter angular unit is `minute of arc`
     * @param value of angle</haxe_doc>
		</addMarc>
		<addSarc public="1" set="method" line="534">
			<f a="value">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* add value to angle object. Incoming parameter angular unit is `second of arc`
     * @param value of angle</haxe_doc>
		</addSarc>
		<addAngle public="1" set="method" line="542">
			<f a="angle">
				<c path="geometryxd.Angle"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* add angle object to angle object
     * @param angle incoming angle object</haxe_doc>
		</addAngle>
		<diffAngle public="1" set="method" line="548">
			<f a="angle">
				<c path="geometryxd.Angle"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* subtract angle object from angle object
     * @param angle incoming angle object</haxe_doc>
		</diffAngle>
		<copy public="1" set="method" line="553">
			<f a=""><c path="geometryxd.Angle"/></f>
			<haxe_doc>* new angle object, with similar value</haxe_doc>
		</copy>
		<minus public="1" set="method" line="560">
			<f a=""><c path="geometryxd.Angle"/></f>
			<haxe_doc>* new angle object, with negative value</haxe_doc>
		</minus>
		<new public="1" set="method" line="67">
			<f a="?unit:?value" v=":0">
				<x path="geometryxd.AngleUnit"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ value : 0 }</e></m></meta>
			<haxe_doc>* new angle object with few unit of measurement functionality. Created new instance angle default value is 0, default unit is `Turn`.
     * @param unit None = 0; Turn = 1; Mulp = 2; Quad = 3; Sext = 4; Rad = 5; Hexa = 6; Bdeg = 7; Deg = 8; Grad = 9; Marc = 10; Sarc = 11;
     * @param value</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Angle object with few unit of measurement functionality. Created new instance angle value is 0.
 * Internal storage unit is `turn`. Alternative names is `cyc`(circle), `rev`(revolution), `rot`(complete rotation).
 * 
 * set value methods available for units:
 * * useTurn(...) -> turn
 * * useMulp(...) -> `multiples of Math.PI`
 * * useQuad(...) -> `quadrant`
 * * useSext(...) -> `sextant`
 * * useRad(...) -> `radian`
 * * useHexa(...) -> `hexacontade`
 * * useBdeg(...) -> `binary degree`
 * * useDeg(...) -> `degree`
 * * useGrad(...) -> `grad`
 * * useMarc(...) -> `minute of arc`
 * * useSarc(...) -> `second of arc`
 * 
 * get value methods available for units:
 * * turn() -> turn
 * * mulp() -> `multiples of Math.PI`
 * * quad() -> `quadrant`
 * * sext() -> `sextant`
 * * rad() -> `radian`
 * * hexa() -> `hexacontade`
 * * bdeg() -> `binary degree`
 * * deg() -> `degree`
 * * grad() -> `grad`
 * * marc() -> `minute of arc`
 * * sarc() -> `second of arc`]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="geometryxd.Dot3D" params="" file="./geometryxd/Dot3D.hx">
		<x public="1">
			<x path="Float"/>
			<haxe_doc>* x coordinate of dot</haxe_doc>
		</x>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>* y coordinate of dot</haxe_doc>
		</y>
		<z public="1">
			<x path="Float"/>
			<haxe_doc>* z coordinate of dot</haxe_doc>
		</z>
		<geo expr="new GeometryXD(false)">
			<c path="geometryxd.GeometryXD"/>
			<meta><m n=":value"><e>new GeometryXD(false)</e></m></meta>
			<haxe_doc>* internal usage of methods</haxe_doc>
		</geo>
		<dd get="inline" set="null" line="41">
			<f a="c">
				<c path="Array"><x path="Float"/></c>
				<c path="geometryxd.Dot3D"/>
			</f>
			<haxe_doc>* internal function. Return Dot3D object from 3D dot coordinates
     * @param c 3D dot coordinates array `[x,y,z]`</haxe_doc>
		</dd>
		<fromArray public="1" set="method" line="49">
			<f a="xyz">
				<c path="Array"><x path="Float"/></c>
				<c path="geometryxd.Dot3D"/>
			</f>
			<haxe_doc>* new Dot3D object from array of coordinates. Used first three array elements. Not enough length replaced uses 0.
     * @param xyz array of 3D dot coordinates `[x,y,z]`</haxe_doc>
		</fromArray>
		<useArray public="1" set="method" line="59">
			<f a="xyz">
				<c path="Array"><x path="Float"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* set `x,y,z` properties using array of coordinates. Used first three array elements. Not enough length replaced uses 0.
     * @param xyz array of 3D dot coordinates `[x,y,z]`</haxe_doc>
		</useArray>
		<useM public="1" set="method" line="69">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* mirror 3D dot coordinates. `[1,2,3]` -> `[-1,-2,-3]`]]></haxe_doc>
		</useM>
		<useMx public="1" set="method" line="78">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* mirror 3D dot x coordinate. `[1,2,3]` -> `[-1,2,3]`]]></haxe_doc>
		</useMx>
		<useMy public="1" set="method" line="85">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* mirror 3D dot y coordinate. `[1,2,3]` -> `[1,-2,3]`]]></haxe_doc>
		</useMy>
		<useMz public="1" set="method" line="92">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* mirror 3D dot z coordinate. `[1,2,3]` -> `[1,2,-3]`]]></haxe_doc>
		</useMz>
		<useMxy public="1" set="method" line="99">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* mirror 3D dot x y coordinates. `[1,2,3]` -> `[-1,-2,3]`]]></haxe_doc>
		</useMxy>
		<useMxz public="1" set="method" line="107">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* mirror 3D dot x z coordinates. `[1,2,3]` -> `[-1,2,-3]`]]></haxe_doc>
		</useMxz>
		<useMyz public="1" set="method" line="115">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* mirror 3D dot y z coordinates. `[1,2,3]` -> `[1,-2,-3]`]]></haxe_doc>
		</useMyz>
		<dn public="1" set="method" line="124">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* number or dot dimensions</haxe_doc>
		</dn>
		<value public="1" set="method" line="132">
			<f a=""><c path="Array"><x path="Float"/></c></f>
			<haxe_doc>* array of dot coordinates `[x,y,z]`</haxe_doc>
		</value>
		<valueM public="1" set="method" line="139">
			<f a=""><c path="Array"><x path="Float"/></c></f>
			<haxe_doc>* array of mirrored values of dot coordinates. If `value()` = `[1,2,3]` return `[-1,-2,-3]`</haxe_doc>
		</valueM>
		<valueMx public="1" set="method" line="146">
			<f a=""><c path="Array"><x path="Float"/></c></f>
			<haxe_doc>* array of values of dot coordinates with mirrored x coordinate. If `value()` = `[1,2,3]` return `[-1,2,3]`</haxe_doc>
		</valueMx>
		<valueMy public="1" set="method" line="153">
			<f a=""><c path="Array"><x path="Float"/></c></f>
			<haxe_doc>* array of values of dot coordinates with mirrored y coordinate. If `value()` = `[1,2,3]` return `[1,-2,3]`</haxe_doc>
		</valueMy>
		<valueMz public="1" set="method" line="160">
			<f a=""><c path="Array"><x path="Float"/></c></f>
			<haxe_doc>* array of values of dot coordinates with mirrored z coordinate. If `value()` = `[1,2,3]` return `[1,2,-3]`</haxe_doc>
		</valueMz>
		<dot3DM public="1" set="method" line="167">
			<f a=""><c path="geometryxd.Dot3D"/></f>
			<haxe_doc>* new 3D dot object with mirrored coordinates. if `value()` = `[1,2,3]` return dot3DM().value() = `[-1,-2,-3]`</haxe_doc>
		</dot3DM>
		<dot3DMx public="1" set="method" line="174">
			<f a=""><c path="geometryxd.Dot3D"/></f>
			<haxe_doc>* new 3D dot object with mirrored x coordinate. if `value()` = `[1,2,3]` return dot3DM().value() = `[-1,2,3]`</haxe_doc>
		</dot3DMx>
		<dot3DMy public="1" set="method" line="181">
			<f a=""><c path="geometryxd.Dot3D"/></f>
			<haxe_doc>* new 3D dot object with mirrored y coordinate. if `value()` = `[1,2,3]` return dot3DM().value() = `[1,-2,3]`</haxe_doc>
		</dot3DMy>
		<dot3DMz public="1" set="method" line="188">
			<f a=""><c path="geometryxd.Dot3D"/></f>
			<haxe_doc>* new 3D dot object with mirrored z coordinate. if `value()` = `[1,2,3]` return dot3DM().value() = `[1,2,-3]`</haxe_doc>
		</dot3DMz>
		<copy public="1" set="method" line="195">
			<f a=""><c path="geometryxd.Dot3D"/></f>
			<haxe_doc>* new 3D dot object with same coordinates. if `value()` = `[1,2,3]` return dot3DM().value() = `[1,2,3]`</haxe_doc>
		</copy>
		<new public="1" set="method" line="31">
			<f a="?x:?y:?z" v="0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ z : 0, y : 0, x : 0 }</e></m></meta>
			<haxe_doc>* new 3D dot object.
     * @param x coordinate of dot
     * @param y coordinate of dot
     * @param z coordinate of dot</haxe_doc>
		</new>
		<haxe_doc>* 3D dot object</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="geometryxd.DotXD" params="" file="./geometryxd/DotXD.hx">
		<coordinates public="1">
			<c path="Array"><x path="Float"/></c>
			<haxe_doc>* array of dot coordinates</haxe_doc>
		</coordinates>
		<useArray public="1" set="method" line="25">
			<f a="coordinates">
				<c path="Array"><x path="Float"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* set multidimensional dot coordinates properties using array of coordinates.
     * @param coordinates array of multidimensional dot coordinates `[x,y,...,z]`</haxe_doc>
		</useArray>
		<fromArray public="1" set="method" line="33">
			<f a="coordinates">
				<c path="Array"><x path="Float"/></c>
				<c path="geometryxd.DotXD"/>
			</f>
			<haxe_doc>* new DotXD object from array of coordinates.
     * @param coordinates array of multidimensional dot coordinates `[x,y,...,z]`</haxe_doc>
		</fromArray>
		<geo expr="new GeometryXD(false)">
			<c path="geometryxd.GeometryXD"/>
			<meta><m n=":value"><e>new GeometryXD(false)</e></m></meta>
			<haxe_doc>* internal usage of methods</haxe_doc>
		</geo>
		<dn public="1" set="method" line="48">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* number or dot dimensions</haxe_doc>
		</dn>
		<value public="1" set="method" line="53"><f a=""><c path="Array"><x path="Float"/></c></f></value>
		<valueM public="1" set="method" line="60">
			<f a=""><c path="Array"><x path="Float"/></c></f>
			<haxe_doc>* array of mirrored values of dot coordinates. If `value` = `[1,2,3,-4]` return `[-1,-2,-3,4]`</haxe_doc>
		</valueM>
		<dotXDM public="1" set="method" line="67">
			<f a=""><c path="geometryxd.DotXD"/></f>
			<haxe_doc>* new multidimensional dot object with mirrored coordinates. If `value` = `[1,2,3,-4]` return dotXD().value = `[-1,-2,-3,4]`</haxe_doc>
		</dotXDM>
		<copy public="1" set="method" line="74">
			<f a=""><c path="geometryxd.DotXD"/></f>
			<haxe_doc>* new multidimensional dot object with same coordinates. if `value` = `[1,2,3,-4]` return dotXD().value = `[1,2,3,-4]`</haxe_doc>
		</copy>
		<new public="1" set="method" line="16">
			<f a="dotXD">
				<c path="Array"><x path="Float"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* new multidimentional dot object.
     * @param dotXD - array of dot coordinates</haxe_doc>
		</new>
		<haxe_doc>* multidimensional dot object</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="geometryxd.GeometryXD" params="" file="./geometryxd/GeometryXD.hx">
		<main public="1" set="method" line="23" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>trace `GeometryXD connected` message in time of initialisation</haxe_doc>
		</main>
		<nm public="1">
			<c path="geometryxd.NM"/>
			<haxe_doc>NM instance. number manipulation</haxe_doc>
		</nm>
		<am public="1">
			<c path="geometryxd.AM"/>
			<haxe_doc>AM instance. array manipulation</haxe_doc>
		</am>
		<cxyz final="1" public="1" expr="[0, 0, 0]">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[0, 0, 0]</e></m></meta>
			<haxe_doc>center 3D coordinate system. Zero point value [0,0,0]</haxe_doc>
		</cxyz>
		<vecXDnorm public="1" set="method" line="49">
			<f a="vecXD">
				<c path="Array"><x path="Float"/></c>
				<x path="Float"/>
			</f>
			<haxe_doc>return vector length (other names "norm" or "magnitude").
     For `[2,3]` return Math.sqrt((2 * 2) + (3 * 3))
     @param vecXD - incoming vector</haxe_doc>
		</vecXDnorm>
		<vecXDfieldnorm public="1" get="inline" set="null" line="58">
			<f a="vecXDfield">
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>return array of lengths of vectors
     @param vecXDfield - incoming vectors array(vector field)</haxe_doc>
		</vecXDfieldnorm>
		<zero_vector_inside public="1" get="inline" set="null" line="68">
			<f a="vecXDfield">
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
				<x path="Null"><x path="Bool"/></x>
			</f>
			<haxe_doc><![CDATA[* return true if vector field include zero vector
     * @param vecXDfield multidimensional vector field
     * @return Null<Bool>]]></haxe_doc>
		</zero_vector_inside>
		<vecXD public="1" set="method" line="82">
			<f a="dotXDb:?dotXDa">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>return vector builded uses two dots
     @param dotXDb - vector end dot
     @param dotXDa - vector start dot. Default will be `[0,...,0]`</haxe_doc>
		</vecXD>
		<vecXDone public="1" set="method" line="101">
			<f a="vecXD">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>recount vector to length equal 1 or return incoming vector as result if incoming vector length equal 0
     @param vecXD - incoming vector</haxe_doc>
		</vecXDone>
		<vecXDfield public="1" set="method" line="114">
			<f a="dots">
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
			</f>
			<haxe_doc>return vector field from first dot to each other
     @param dots - dots field for vector field. `dots[0]` used as first dot</haxe_doc>
		</vecXDfield>
		<vecXDsame public="1" get="inline" set="null" line="124">
			<f a="vecXDa:vecXDb">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<x path="Null"><x path="Bool"/></x>
			</f>
			<haxe_doc>compare vectors. Returns true if vectors have equal data
     @param vecXDa - incoming vector
     @param vecXDb - incoming vector</haxe_doc>
		</vecXDsame>
		<vecXDfieldsame public="1" get="inline" set="null" line="137">
			<f a="vecXDfield">
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
				<x path="Null"><x path="Bool"/></x>
			</f>
			<haxe_doc>compare vectors from vector field. Returns true if all vectors have same data
     @param vecXDfield - vector field(array of vectors)</haxe_doc>
		</vecXDfieldsame>
		<vecXDrandom public="1" set="method" line="142">
			<f a="?x" v="3">
				<x path="Int"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":value"><e>{ x : 3 }</e></m></meta>
			<haxe_doc><![CDATA[return random vector with length equal 1
     @param x - number of vector dimension. For example x = 3 -> 3D vector, x = 4 -> 4D vector]]></haxe_doc>
		</vecXDrandom>
		<vecXDsum public="1" set="method" line="156">
			<f a="vecXDa:vecXDb">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>return vector, which is sum of two vectors
     @param vecXDa - vector
     @param vecXDb - vector</haxe_doc>
		</vecXDsum>
		<vecXDfieldsum public="1" set="method" line="166">
			<f a="vecXDfield">
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>return vector, which is sum of vector field
     @param vecXDfield - vector field (array of vectors)</haxe_doc>
		</vecXDfieldsum>
		<vecXDdiff public="1" set="method" line="174">
			<f a="vecXDa:vecXDb">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>return vector, which is diff of vectors. vecXDa - vecXDb
     @param vecXDa - vector
     @param vecXDb - vector</haxe_doc>
		</vecXDdiff>
		<vecXDfielddiff public="1" set="method" line="184">
			<f a="vecXDfield">
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>return vector, which is diff of vector field. v0-v1...-vn
     @param vecXDfield - vector field(array of vectors)</haxe_doc>
		</vecXDfielddiff>
		<vecXDback public="1" set="method" line="191">
			<f a="vecXD">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>return opposite vector. [1, 2, -4] return [-1, -2, 4]
     @param vecXD - vector</haxe_doc>
		</vecXDback>
		<vecXDfieldback public="1" set="method" line="198">
			<f a="vecXDfield">
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
			</f>
			<haxe_doc>return opposite vector field. [[1, 2], [3, -4]] return [[-1, -2], [-3, 4]]
     @param vecXDfield - vector field(array of vectors)</haxe_doc>
		</vecXDfieldback>
		<vecXDparalleled_sameside public="1" set="method" line="207">
			<f a="vecXDa:vecXDb">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<x path="Null"><x path="Bool"/></x>
			</f>
			<haxe_doc>return true if vectors paralleled and have same direction
     @param vecXDa - vector
     @param vecXDb - vector</haxe_doc>
		</vecXDparalleled_sameside>
		<vecXDparalleled_opposite public="1" set="method" line="222">
			<f a="vecXDa:vecXDb">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<x path="Null"><x path="Bool"/></x>
			</f>
			<haxe_doc>return true if vectors paralleled and have opposite direction
     @param vecXDa - vector
     @param vecXDb - vector</haxe_doc>
		</vecXDparalleled_opposite>
		<vecXDparalleled public="1" set="method" line="235">
			<f a="vecXDa:vecXDb">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<x path="Bool"/>
			</f>
			<haxe_doc>return true if vectors paralleled
     @param vecXDa - vector
     @param vecXDb - vector</haxe_doc>
		</vecXDparalleled>
		<vecXDscalar public="1" set="method" line="247">
			<f a="vecXDa:vecXDb">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<x path="Null"><x path="Float"/></x>
			</f>
			<haxe_doc>return scalar product of vectors
     @param vecXDa - vector
     @param vecXDb - vector</haxe_doc>
		</vecXDscalar>
		<vecXDcos public="1" set="method" line="262">
			<f a="vecXDa:vecXDb">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<x path="Null"><x path="Float"/></x>
			</f>
			<haxe_doc>return cos between vectors
     @param vecXDa - vector
     @param vecXDb - vector</haxe_doc>
		</vecXDcos>
		<vecXDangle public="1" set="method" line="279">
			<f a="vecXDa:vecXDb:?rad" v="::false">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<x path="Bool"/>
				<x path="Null"><x path="Float"/></x>
			</f>
			<meta><m n=":value"><e>{ rad : false }</e></m></meta>
			<haxe_doc>return angle between vectors
     @param vecXDa - vector
     @param vecXDb - vector
     @param rad - if true then return radians angle, default false(degrees angle)</haxe_doc>
		</vecXDangle>
		<vec3Dnormal public="1" set="method" line="298">
			<f a="vec3Da:vec3Db">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>return vector 3D, which is result of cross product of vectors (normal vector of plane based on two vectors). 
     Result vector placed so if you will see from end of result vector, then the rotating direction will be 
     CCW from vec3Da to vec3Db
     @param vec3Da - vector
     @param vec3Db - vector</haxe_doc>
		</vec3Dnormal>
		<vec3Dfieldnormal public="1" set="method" line="315">
			<f a="vec3Dfield">
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>return vector 3D, which is result of step by step cross product for each next vector 3D 
     from vector field with previous cross product result vector 3D
     @param vec3Dfield - vector field 3D(array of vectors 3D)</haxe_doc>
		</vec3Dfieldnormal>
		<vecXDmiddle public="1" set="method" line="330">
			<f a="vecXDa:vecXDb">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>return vector with middle value. Just call middle_xF([vecXDa, vecXDb])
     @param vecXDa - vector
     @param vecXDb - vector</haxe_doc>
		</vecXDmiddle>
		<vecXDfieldmiddle public="1" set="method" line="340">
			<f a="vecXDfield">
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>return vector with middle value. Just call middle_xF(vecXDfield)
     @param vecXDfield - vector field(array of vectors)</haxe_doc>
		</vecXDfieldmiddle>
		<vecXDsamesize public="1" set="method" line="348">
			<f a="vecXDa:vecXDb">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<x path="Null"><x path="Bool"/></x>
			</f>
			<haxe_doc>return true if vectors have same size. Bonus function. Just call same_size_F([vecXDa, vecXDb])
     @param vecXDa - vector
     @param vecXDb - vector</haxe_doc>
		</vecXDsamesize>
		<vecXDfieldsamesize public="1" set="method" line="358">
			<f a="vecXDfield">
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
				<x path="Null"><x path="Bool"/></x>
			</f>
			<haxe_doc>return true if vector from vector field have same size. Bonus function. Just call same_size_F(vecXDfield)
     @param vecXDfield - vector field(array of vectors)</haxe_doc>
		</vecXDfieldsamesize>
		<dotXDoffset public="1" set="method" line="368">
			<f a="dotXD:vecXD:t">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<x path="Float"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>return dot, which result of offset dotXD along vecXD to t
     @param dotXD - dot
     @param vecXD - vector
     @param t - distance</haxe_doc>
		</dotXDoffset>
		<dot3Dline3D_x_plane3D public="1" set="method" line="394">
			<f a="dot3D0:vec3D0:vec3Dplane:?dplane" v=":::0">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<x path="Float"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":value"><e>{ dplane : 0 }</e></m></meta>
			<haxe_doc>return dot 3D, which is intersection dot for line3D(dot3D0, vec3D0) and plane3D(vec3Dplane, dplane)
     @param dot3D0 - dot 3D start for line
     @param vec3D0 - vector 3D of line direction
     @param vec3Dplane - vector 3D, which is plane 3D normal vector
     @param dplane - displacement of plane 3D from [0,0,0]. default 0 ([0,0,0] dot belongs to the plane)</haxe_doc>
		</dot3Dline3D_x_plane3D>
		<projection_dot3D_on_plane3D public="1" set="method" line="431">
			<f a="dot3D:plane3D">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>return dot 3D, which is projection of dot3D to plane3D
     @param dot3D - dot 3D, which is [x, y, z]
     @param plane3D - plane 3D, which is [a, b, c, d]. 
     Where (a, b, c) - normal vector of plane 3D. (d) - distance from (0, 0, 0). 
     if d = 0, then the plane passes through the center of coordinates</haxe_doc>
		</projection_dot3D_on_plane3D>
		<dot3D_to_dot2Dviewplane public="1" set="method" line="466">
			<f a="dot3D:dot3Dviewplanecenter:vec3Dviewplane:vec3Dviewplane_ox">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>return dot 2D (x, y) from dot3D projected on view plane, View plane determined by coordinate axes center plane 3D dot, and plane 3D normal vector. 
     View plane vector 3D of axis ox, will be projected to view plane. Incoming value can not be strictly belongs to the view plane.
     @param dot3D - dot 3D (x, y ,z) which will be projected
     @param dot3Dviewplanecenter - view plane 3D center dot. 
     Used as coordinate axes center 
     @param vec3Dviewplane - view plane normal vector 3D ()
     @param vec3Dviewplane_ox - vector 3D of axis ox. 
     Must be not parelleled view plane normal vector. 
     Second axis will be calculated automatically, 
     uses rotate projected ox around view plane normal vector</haxe_doc>
		</dot3D_to_dot2Dviewplane>
		<dotXDscale public="1" set="method" line="500">
			<f a="dotXD:scaleXD:dotXDc">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>returns dot with scaled values relative to the scaling center
     @param dotXD - dot . For 3D case [x, y, z]
     @param scaleXD - scales array . For 3D case [sx, sy, sz]
     @param dotXDc - scaling center dot . For 3D case [xc, yc, zc]</haxe_doc>
		</dotXDscale>
		<vec3Drotate public="1" set="method" line="519">
			<f a="vec3D:vec3Daxis:angle:?rad" v=":::false">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":value"><e>{ rad : false }</e></m></meta>
			<haxe_doc>returns vector 3D, rotated around axis vector to angle
     @param vec3D - vector 3D
     @param vec3Daxis - axis of rotation . vector 3D
     @param angle - angle of rotation
     @param rad - if true then radians angle, default false (degrees angle)</haxe_doc>
		</vec3Drotate>
		<vec3Dfield_rotate_around_vec3Daxes public="1" set="method" line="550">
			<f a="vec3Dfield:vec3Daxes:angles:?rad" v=":::false">
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
				<c path="Array"><x path="Float"/></c>
				<x path="Bool"/>
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
			</f>
			<meta><m n=":value"><e>{ rad : false }</e></m></meta>
			<haxe_doc>returns vector 3D field, each vector of which rotated to own angle, around own axis
     @param vec3Dfield - vector 3D field(array of vectors)
     @param vec3Daxes - axes 3D field(array of vectors)
     @param angles - angles of rotating for each vector
     @param rad - if true then radians angles, default false (degrees angles)</haxe_doc>
		</vec3Dfield_rotate_around_vec3Daxes>
		<dot3Drotate public="1" set="method" line="582">
			<f a="dot3D:dot3Dc:vec3D:angle:?rad" v="::::false">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":value"><e>{ rad : false }</e></m></meta>
			<haxe_doc>returns dot 3D, rotated to angle, around center of rotation determined by dot and axis of rotation
     @param dot3D - dot 3D
     @param dot3Dc - rotation center dot 3D
     @param vec3D - rotation axis vector 3D
     @param angle - rotation angle
     @param rad - if true then radians angle, default false (degrees angle)</haxe_doc>
		</dot3Drotate>
		<plane3D_dot3Dnormal public="1" set="method" line="608">
			<f a="dot3D:vec3D">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>returns plane 3D (a, b, c, d) determined by dot 3D and vector 3D.
     Where (a, b, c) is plane 3D normal vector, and (d) is displacement plane from (0, 0, 0)
     @param dot3D - dot 3D
     @param vec3D - plane 3D normal vector 3D</haxe_doc>
		</plane3D_dot3Dnormal>
		<plane3D_dot_vec_vec public="1" set="method" line="627">
			<f a="dot3D:vec3Da:vec3Db">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>returns plane 3D (a, b, c, d), determined by dot and two not paralleled vectors. 
     Where (a, b, c) is plane 3D normal vector, and (d) is displacement plane from (0, 0, 0)
     @param dot3D - dot 3D
     @param vec3Da - vector 3D
     @param vec3Db - vector 3D</haxe_doc>
		</plane3D_dot_vec_vec>
		<plane3D_3dots public="1" set="method" line="651">
			<f a="dot3D:dot3Da:dot3Db">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>returns plane 3D (a, b, c, d), determined by three not equal dots. 
     Where (a, b, c) is plane 3D normal vector, and (d) is displacement plane from (0, 0, 0)
     @param dot3D - dot 3D
     @param dot3Da - dot 3D
     @param dot3Db - dot 3D</haxe_doc>
		</plane3D_3dots>
		<plane3D_2dots public="1" set="method" line="677">
			<f a="dot3D:dot3Da">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>returns plane 3D (a, b, c, d), determined by two not equal dots. 
     Where (a, b, c) is plane 3D normal vector, and (d) is displacement plane from (0, 0, 0)
     @param dot3D - dot 3D
     @param dot3Da - dot 3D</haxe_doc>
		</plane3D_2dots>
		<distance_dot3D_plane3D public="1" set="method" line="695">
			<f a="dot3D:plane3D">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<x path="Null"><x path="Float"/></x>
			</f>
			<haxe_doc>returns distance from dot 3D to plane 3D
     @param dot3D - dot 3D (x, y, z)
     @param plane3D - plane 3D (a, b, c, d). 
     Where (a, b, c) is plane 3D normal vector, and (d) is displacement plane from (0, 0, 0)</haxe_doc>
		</distance_dot3D_plane3D>
		<random_vec3D_in_plane3D public="1" set="method" line="715">
			<f a="plane3D">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>returns a random vector 3D paralleled to the plane 3D(lies on plane 3D)
     @param plane3D - plane 3D (a, b, c, d). 
     Where (a, b, c) is plane 3D normal vector, and (d) is displacement plane from (0, 0, 0)</haxe_doc>
		</random_vec3D_in_plane3D>
		<random_dot3D_in_plane3D public="1" set="method" line="739">
			<f a="plane3D:dot3D:radius">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<x path="Float"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>returns random dot 3D belongs on plane 3D
     @param plane3D - plane 3D (a, b, c, d). 
     Where (a, b, c) is plane 3D normal vector, and (d) is displacement plane from (0, 0, 0)
     @param dot3D - dot 3D . Determine start position for round area on plane 3D for calculating result. 
     If dot not in plane , then will be uesd projection this dot on plane
     @param radius - radius of round area on plane 3D. Result will be calculated inside area</haxe_doc>
		</random_dot3D_in_plane3D>
		<curve3D_4dots public="1" set="method" line="768">
			<f a="dot3D1:vec3D1:distance1:dot3D2:vec3D2:distance2">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<x path="Float"/>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<x path="Float"/>
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
			</f>
			<haxe_doc>returns curve 3D ((x, y, z), (x, y, z), (x, y, z), (x, y, z)) 
     with internal dots, calculated use offset from border dots along levers to distances. 
     The resul curve 3D have 4 dots 3D, two border dots incoming, and two internal dots calculated. 
     Result will [dot3D1, dot3D1offset, dot3D2offset, dot3D2]
     @param dot3D1 - dot 3D (x, y, z) start curve incoming dot
     @param vec3D1 - vector 3D (a, b, c) for offset start internal dot
     @param distance1 - distance for offset start internal dot along offset vector
     @param dot3D2 - dot 3D (x, y, z) end curve incoming dot
     @param vec3D2 - vector 3D (a, b, c) for offset end internal dot
     @param distance2 - distance for offset end internal dot along offset vector</haxe_doc>
		</curve3D_4dots>
		<curve3D_3dots public="1" set="method" line="803">
			<f a="dot3D0:dot3D1:dot3D2:?lever1:?lever2:?a_s" v=":::0.55:0.55:-1">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
			</f>
			<meta><m n=":value"><e>{ a_s : -1, lever2 : 0.55, lever1 : 0.55 }</e></m></meta>
			<haxe_doc><![CDATA[returns curve 3D ((x, y, z), (x, y, z), (x, y, z), (x, y, z)). 
     Shape of result curve will be close to arc (1/4 ellipse). 
     Allowed few variants of result curve modification(distortion).
     Default lever1 and lever2 values equal 0.55.
     The 0.55 value in case of bezier cubic 3D curve will create shape close to ellipse arc.
     @param dot3D0 - center of ellipse trajectory dot 3D (x, y, z)
     @param dot3D1 - first arc dot 3D (x, y, z)
     @param dot3D2 - last arc dot 3D (x, y, z)
     @param lever1 - length of offset the first support dot along lever1 vector (depended of a_s)
     @param lever2 - length of offset the last support dot along lever2 vector (depended of a_s)
     @param a_s - arc style. Determine of arc calculation way. 
     if a_s > 0 then lever1 vector will be directed from dot3D0 to dot3D1. lever2 vector from dot3D0 to dot3D2 
     if a_s < 0 then lever1 vector will be directed from dot3D0 to dot3D2. lever2 vector from dot3D0 to dot3D1 
     if a_s = 0 then lever1 vector will be paralleled lever2 vector and both will be directed 
     from dot3D0 to dot between dot3D1 and dot3D2 center dot]]></haxe_doc>
		</curve3D_3dots>
		<line3D_2dots public="1" set="method" line="851">
			<f a="dot3D0:dot3D1">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
			</f>
			<haxe_doc>returns line 3D ((x, y, z), (x, y, z), (x, y, z), (x, y, z)). 
     Which is (dot3D0, 1/3 offset, 2/3 offset, dot3D1). 
     Comfort for use as bezier cubic curve 3D as straight line
     @param dot3D0 - start line dot 3D
     @param dot3D1 - end line dot 3D</haxe_doc>
		</line3D_2dots>
		<line3D_dot_offset public="1" set="method" line="874">
			<f a="dot3D:vec3D:distance">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<x path="Float"/>
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
			</f>
			<haxe_doc>returns line 3D ((x, y, z), (x, y, z), (x, y, z), (x, y, z)). 
     Just call line3D_2dots with precalculated second dot 3D
     @param dot3D - start line dot 3D
     @param vec3D - offset start line dot vector 3D
     @param distance - offset distance for end line dot</haxe_doc>
		</line3D_dot_offset>
		<curve3D_4to12 public="1" get="inline" set="null" line="894">
			<f a="curve">
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>returns curve 3D as 12 coordinates, recounted from 4 dots 3D. 
     [[x, y, z], [x, y, z], [x, y, z], [x, y, z]] return [x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4]
     @param curve - curve 3D ((x, y, z), (x, y, z), (x, y, z), (x, y, z))</haxe_doc>
		</curve3D_4to12>
		<curve3D_12to4 public="1" get="inline" set="null" line="909">
			<f a="curve">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
			</f>
			<haxe_doc>returns curve 3D as 4 dots 3D, recounted from 12 coordinates. 
     [x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4] return [[x, y, z], [x, y, z], [x, y, z], [x, y, z]]
     @param curve - curve 3D data (x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4)</haxe_doc>
		</curve3D_12to4>
		<beziercubic3D_derivativeparameters public="1" get="inline" set="null" line="920">
			<f a="curve">
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
			</f>
			<haxe_doc>beziercubic3D_derivative bonus function. returns parameters for derivative calculation. 
     [[x1, y1, z1], [x2, y2, z2], [x3, y3, z3], [x4, y4, z4]] return [[x1,x2,x3,x4],[y1,y2,y3,y4],[z1,z2,z3,z4]]
     @param curve - bezier cubic curve 3D ((x1, y1, z1), (x2, y2, z2), (x3, y3, z3), (x4, y4, z4))</haxe_doc>
		</beziercubic3D_derivativeparameters>
		<beziercubic_derivative public="1" get="inline" set="null" line="932">
			<f a="bcp:p">
				<c path="Array"><x path="Float"/></c>
				<x path="Float"/>
				<x path="Null"><x path="Float"/></x>
			</f>
			<haxe_doc>return bezier cubic curve derivative for each dimension. Usual case `x` or `y` or `z`
     @param bcp - bezier curve derivative parameters, precalculated uses `beziercubic3D_derivativeparameters(...)`
     @param p - bezier cubic curve parameter. Standart values equal range 0...1 include borders</haxe_doc>
		</beziercubic_derivative>
		<beziercubic3D_derivative public="1" set="method" line="948">
			<f a="curve:p">
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
				<x path="Float"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>returns bezier cubic curve 3D derivative
     @param curve - bezier cubic curve 3D ((x, y, z), (x, y, z), (x, y, z), (x, y, z))
     @param p - bezier cubic curve parameter. Standart values equal range 0...1 include borders</haxe_doc>
		</beziercubic3D_derivative>
		<beziercubic_support_dot_one public="1" get="inline" set="null" line="966">
			<f a="beziercubic_one_axis_coordinates">
				<c path="Array"><x path="Float"/></c>
				<x path="Null"><x path="Float"/></x>
			</f>
			<haxe_doc>returns cubic bezier curve support dot one(first lever) paramater for each coordinate. Usual case `x` or `y` or `z`
     @param beziercubic_one_axis_coordinates - [c1,c2,c3,c4]. Where c is cubic bezier curve trajectory dots values for one of `x` or `y` or `z`</haxe_doc>
		</beziercubic_support_dot_one>
		<beziercubic3D_support_dot_one public="1" set="method" line="976">
			<f a="curve3D_4dots">
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>returns dot 3D, which is bezier cubic curve 3D support dot one(first lever)
     @param curve3D_4dots - curve 3D trajectory, which is [[x1, y1, z1], [x2, y2, z2], [x3, y3, z3], [x4, y4, z4]]</haxe_doc>
		</beziercubic3D_support_dot_one>
		<beziercubic_support_dot_two public="1" get="inline" set="null" line="986">
			<f a="beziercubic_one_axis_coordinates">
				<c path="Array"><x path="Float"/></c>
				<x path="Null"><x path="Float"/></x>
			</f>
			<haxe_doc>returns cubic bezier curve support dot two(second lever) paramater for each coordinate. Usual case `x` or `y` or `z`
     @param beziercubic_one_axis_coordinates - [c1,c2,c3,c4]. Where c is cubic bezier curve trajectory dots values for one of `x` or `y` or `z`</haxe_doc>
		</beziercubic_support_dot_two>
		<beziercubic3D_support_dot_two public="1" set="method" line="996">
			<f a="curve3D_4dots">
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>returns dot 3D, which is bezier cubic curve 3D support dot two(second lever)
     @param curve3D_4dots - curve 3D trajectory, which is [[x1, y1, z1], [x2, y2, z2], [x3, y3, z3], [x4, y4, z4]]</haxe_doc>
		</beziercubic3D_support_dot_two>
		<beziercubic3D_follow_4dots_trajectory public="1" get="inline" set="null" line="1006">
			<f a="dots">
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
			</f>
			<haxe_doc>returns bezier cubic curve 3D, calculated from 4dots 3D(curve 3D trajectory)
     @param dots - curve 3D trajectory. Must be of the form [[x1, y1, z1], [x2, y2, z2], [x3, y3, z3], [x4, y4, z4]]</haxe_doc>
		</beziercubic3D_follow_4dots_trajectory>
		<beziercubic_coordinate public="1" get="inline" set="null" line="1020">
			<f a="beziercubic_one_axis_coordinates:parameter">
				<c path="Array"><x path="Float"/></c>
				<x path="Float"/>
				<x path="Null"><x path="Float"/></x>
			</f>
			<haxe_doc>returns bezier cubic coordinate for each one axis. Usual case `x` or `y` or `z`
     @param beziercubic_one_axis_coordinates - Must be of the form (c1, c2, c3, c4). 
     For case [[x1, y1, z1], [x2, y2, z2], [x3, y3, z3], [x4, y4, z4]] curve and x axis must be [x1, x2, x3, x4]
     @param parameter - parameter of bezier curve equation. Usual case range 0...1 include borders</haxe_doc>
		</beziercubic_coordinate>
		<beziercubic3Ddot public="1" set="method" line="1040">
			<f a="beziercubic3D:parameter">
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
				<x path="Float"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>returns dot 3D, belongs on bezier cubic curve 3D
     @param beziercubic3D - curve 3D, which must be of the form [[x1, y1, z1], [x2, y2, z2], [x3, y3, z3], [x4, y4, z4]]. 
     Which is [dot3Dstart, lever3Dstart, lever3Dend, dot3Dend]
     @param parameter - parameter of bezier curve equation. Usual case range 0...1 include borders</haxe_doc>
		</beziercubic3Ddot>
		<curve3D_4dots_follow_beziercubic_trajectory public="1" get="inline" set="null" line="1056">
			<f a="beziercubic3D">
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
			</f>
			<haxe_doc>returns curve 3D, which is 4 dots 3D bezier cubic curve, recounted to 4 dots 3D curve. 
     Two internal dots belongs on bezier cubic curve trajectory, with parameter 1/3 and 2/3
     @param beziercubic3D - curve 3D, which must be of the form [[x1, y1, z1], [x2, y2, z2], [x3, y3, z3], [x4, y4, z4]]</haxe_doc>
		</curve3D_4dots_follow_beziercubic_trajectory>
		<curve3Doffset public="1" get="inline" set="null" line="1074">
			<f a="curve3D:vec3D:distance">
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
				<c path="Array"><x path="Float"/></c>
				<x path="Float"/>
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
			</f>
			<haxe_doc>returns curve 3D, offsetted along vector 3D to specified distance
     @param curve3D - curve 3D, which must be of the form [[x1, y1, z1], [x2, y2, z2], [x3, y3, z3], [x4, y4, z4]]
     @param vec3D - vector 3D (a, b, c)
     @param distance - displacement distance</haxe_doc>
		</curve3Doffset>
		<curve3Drotate public="1" get="inline" set="null" line="1097">
			<f a="curve3D:dot3D:vec3D:angle:?rad" v="::::false">
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
			</f>
			<meta><m n=":value"><e>{ rad : false }</e></m></meta>
			<haxe_doc>returns curve 3D, rotated around axis(determined by dot 3D and vector 3D) to specified angle
     @param curve3D - curve 3D, which must be of the form [[x1, y1, z1], [x2, y2, z2], [x3, y3, z3], [x4, y4, z4]]
     @param dot3D - dot 3D. Used for rotation axis
     @param vec3D - vector 3D. Used for rotation axis
     @param angle - rotation angle
     @param rad - if true then radians angle, default false (degrees angle)</haxe_doc>
		</curve3Drotate>
		<curve3Dscale public="1" get="inline" set="null" line="1123">
			<f a="curve3D:scale_xyz:dot3D">
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
			</f>
			<haxe_doc>returns curve 3D, scaled relative base dot 3D, uses own scale for each axis
     @param curve3D - curve 3D, which must be of the form [[x1, y1, z1], [x2, y2, z2], [x3, y3, z3], [x4, y4, z4]]
     @param scale_xyz - scale for each axis. Must be of the form [sx, sy, sz]
     @param dot3D - scaling center(base) dot 3D</haxe_doc>
		</curve3Dscale>
		<ellipse2Dperimeter_ramanujan public="1" get="inline" set="null" line="1148">
			<f a="semiaxis_a:semiaxis_b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Null"><x path="Float"/></x>
			</f>
			<haxe_doc>returns ellipse perimeter, calculated use ramanujan method.
     Result will be max from perimeters, calculated by two ramanujan methods, with negative errors
     @param semiaxis_a - ellipse a semiaxes. Usual paralleled x axis
     @param semiaxis_b - ellipse b semiaxes. Usual paralleled y axis</haxe_doc>
		</ellipse2Dperimeter_ramanujan>
		<tangent_centered_ellipse2Ddot public="1" set="method" line="1180">
			<f a="semiaxis_a:semiaxis_b:ellipse_dot2D">
				<x path="Float"/>
				<x path="Float"/>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
			</f>
			<haxe_doc>returns vector 2D, which is tangent of centered ellipse 2D
     @param semiaxis_a - ellipse a semiaxes. Usual paralleled x axis
     @param semiaxis_b - ellipse b semiaxes. Usual paralleled y axis
     @param ellipse_dot2D - dot 2D belongs to the ellipse perimeter</haxe_doc>
		</tangent_centered_ellipse2Ddot>
		<ellipse_e_parameter public="1" get="inline" set="null" line="1237">
			<f a="semiaxis_a:semiaxis_b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Null"><x path="Float"/></x>
			</f>
			<haxe_doc>returns ellipse e parameter (ellipse eccentricity)
     @param semiaxis_a - ellipse a semiaxes. Usual paralleled x axis
     @param semiaxis_b - ellipse b semiaxes. Usual paralleled y axis</haxe_doc>
		</ellipse_e_parameter>
		<ellipse_c_parameter public="1" set="method" line="1253">
			<f a="semiaxis_a:semiaxis_b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Null"><x path="Float"/></x>
			</f>
			<haxe_doc>returns ellipse c parameter (elipse foci) ... фокальное расстояние (полурасстояние между фокусами)
     @param semiaxis_a - ellipse a semiaxes. Usual paralleled x axis
     @param semiaxis_b - ellipse b semiaxes. Usual paralleled y axis</haxe_doc>
		</ellipse_c_parameter>
		<tangent_vec3D_in_plane_of_ellipse2D_placed_in_3Dspace public="1" set="method" line="1282">
			<f a="dot3D:vec3Dnormal_ellipse_plane:vec3Dsemiaxis_a_direction:semiaxis_a:semiaxis_b:semiaxis_a_negative:semiaxis_b_negative:angle:rad">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>returns vector 3D, which is tangent of ellipse, belongs to the plane 3D
     @param dot3D - ellipse center dot 3D (x, y, z)
     @param vec3Dnormal_ellipse_plane - ellipse plane 3D normal vector (a, b, c)
     @param vec3Dsemiaxis_a_direction - ellipse semiaxis direction vector 3D (a, b, c). 
     Will be projected on plane, no need strictly vector in plane. enought not paralleled with 
     ellipse plane normal vector
     @param semiaxis_a - ellipse semiaxis a length
     @param semiaxis_b - ellipse semiaxis b length
     @param semiaxis_a_negative - ellipse opposite semiaxis a length. 
     Directed to negative side from projection of vec3Dsemiaxis_a_direction vector
     @param semiaxis_b_negative - ellipse opposite semiaxis b length. Same but for other semiaxis vector
     @param angle - angle for calculating dot 3D, belongs to the ellipse. 
     Calculating will be directed from positive semiaxis a to positive semiaxis b, for positive angle
     @param rad - if true then radians angle, default false(degrees angle)</haxe_doc>
		</tangent_vec3D_in_plane_of_ellipse2D_placed_in_3Dspace>
		<ellipse3D_dots public="1" set="method" line="1335">
			<f a="dot3D:vec3Dsemiaxes:semiaxes">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
			</f>
			<haxe_doc>returns 9 dots 3D, ellipse center dot and 8 ellipse perimeter dots
     @param dot3D - ellipse center dot 3D
     @param vec3Dsemiaxes - array of semiaxes vectors 3D. Include 4 semiaxes vectors 3D.
     Must be of the form [[a1, b1, c1], [a2, b2, c2], [a3, b3, c3], [a4, b4, c4]]. 
     Which is [a, b, an, bn], where an and bn is negative semiaxes direction vectors 
     @param semiaxes - array of semiaxes lengths. Must be of the form [a, b, an, bn]</haxe_doc>
		</ellipse3D_dots>
		<ellipse2Ddot public="1" get="inline" set="null" line="1377">
			<f a="angle:semiaxis_a_ox:semiaxis_b_oy:?rad" v=":::false">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":value"><e>{ rad : false }</e></m></meta>
			<haxe_doc>returns dot 2D, which belongs to ellipse perimeter
     @param angle - angle of ellipse from semiaxis a to semiaxis b direction, for positive angle
     @param semiaxis_a_ox - semiaxis a length
     @param semiaxis_b_oy - semiaxis b length
     @param rad - if true then radians angle, default false(degrees angle)</haxe_doc>
		</ellipse2Ddot>
		<curve2D_4dots_elliptic_shape_restricted_to_quarter public="1" set="method" line="1397">
			<f a="angle0:angle1:semiaxis_a_ox:semiaxis_b_oy:?rad" v="::::false">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
			</f>
			<meta><m n=":value"><e>{ rad : false }</e></m></meta>
			<haxe_doc>returns curve 2D, which have ellipse shape restricted to quarter
     @param angle0 - start angle from semiaxis a to semiaxis b direction
     @param angle1 - angle from semiaxis a to semiaxis b direction started from end of `angle0`
     @param semiaxis_a_ox - length of semiaxis a (ox)
     @param semiaxis_b_oy - length of semiaxis b (oy)
     @param rad - if true then radians angle, default false(degrees angle)</haxe_doc>
		</curve2D_4dots_elliptic_shape_restricted_to_quarter>
		<beziercubic3D_elliptic_shape_restricted_to_quarter public="1" set="method" line="1428">
			<f a="dot3Dc:vec3D_a_ox:vec3D_b_oy:semiaxis_a_ox:semiaxis_b_oy:angle0:angle1:?rad" v=":::::::false">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
			</f>
			<meta><m n=":value"><e>{ rad : false }</e></m></meta>
			<haxe_doc>returns bezier curve 3D, which have ellipse shape restricted to quarter. 
     Result will have form [[x1, y1, z1], [x2, y2, z2], [x3, y3, z3], [x4, y4, z4]]
     @param dot3Dc - center ellipse dot 3D
     @param vec3D_a_ox - semiaxis a direction vector 3D
     @param vec3D_b_ox - semiaxis b direction vector 3D
     @param semiaxis_a_ox - semiaxis a length
     @param semiaxis_b_oy - semiaxis b length
     @param angle0 - start angle from semiaxis a to semiaxis b direction
     @param angle1 - angle from semiaxis a to semiaxis b direction started from end of `angle0`
     @param rad - if true then radians angle, default false(degrees angle)</haxe_doc>
		</beziercubic3D_elliptic_shape_restricted_to_quarter>
		<angle_required_to_place_curve_on_ellipse public="1" set="method" line="1466">
			<f a="curve_length:semiaxis_a_ox:semiaxis_b_oy:angle0:?rad" v="::::false">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Null"><x path="Float"/></x>
			</f>
			<meta><m n=":value"><e>{ rad : false }</e></m></meta>
			<haxe_doc>returns angle required to place curve on ellipse. 
     Max returned value is 360 degrees, or radians same value angle
     @param curve_length - length of curve for placing on ellipse
     @param semiaxis_a_ox - semiaxis a length
     @param semiaxis_b_oy - semiaxis b length
     @param angle0 - start angle from semiaxis a to semiaxis b direction. 
     Curve placing started from end of `angle0`
     @param rad - if true then radians angle, default false(degrees angle)</haxe_doc>
		</angle_required_to_place_curve_on_ellipse>
		<polygon3D_inside_ellipse public="1" set="method" line="1502">
			<f a="dot3D:vec3Dsemiaxes:semiaxes:angle_proportions">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
			</f>
			<haxe_doc>returns polygon 3D dots array, which is poligon center dot and array of polygon perimeter dots. 
     Result will have form [`dot3D`, dot3D(1), ... ,dot3D(`angle_proportion.length`)]
     @param dot3D - polygon center dot 3D
     @param vec3Dsemiaxes - base ellipse 4 semiaxes vectors, for creating polygon inside ellipse. 
     Must be of the form [[a1, b1, c1], [a2, b2, c2], [a3, b3, c3], [a4, b4, c4]]. 
     Which is [a, b, an, bn], where an and bn is negative semiaxes direction vectors 
     @param semiaxes - array of displacement values of polygon vetexes from center dot in ellipse plane
     @param angle_proportions - proportions array for splitting 360 degrees angle(without units, not matter). 
     `[90, 90, 90, 90]` returns result same as `[1, 1, 1, 1]`, in both cases will be created quadrangle inside ellipse</haxe_doc>
		</polygon3D_inside_ellipse>
		<polygon3D_vec3Dfield_distances public="1" set="method" line="1558">
			<f a="dot3D:vec3Dfield:distances">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
			</f>
			<haxe_doc>polygon on vectors and displacements. Can be not belongs to one plane 3D.
     returns polygon 3D dots array, which is poligon center dot and array of polygon perimeter dots. 
     Result will have form [`dot3D`, dot3D(1), ... ,dot3D(`distances.length`)]
     @param dot3D - polygon center dot 3D
     @param vec3Dfield - polygon vertexes vector field(array of vectors 3D). 
     Each Vertex will be offsetted along own vector
     @param distances - polygon vertexes radial distances array(offset length)</haxe_doc>
		</polygon3D_vec3Dfield_distances>
		<polygon3D_in_plane public="1" set="method" line="1588">
			<f a="dot3D:vec3Dplane_normal:vec3Dsemiaxis_a_direction:angle_proportions:distances">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
			</f>
			<haxe_doc>polygon belongs to plane 3D.
     returns polygon 3D dots array, which is poligon center dot and array of polygon perimeter dots. 
     Result will have form [`dot3D`, dot3D(1), ... ,dot3D(`angle_proportion.length`)]. 
     @param dot3D - polygon center dot 3D
     @param vec3Dplane_normal - polygon plane normal vector 3D
     @param vec3Dsemiaxis_a_direction - semiaxis a, will be used as start vector of first vertex. 
     Every next vertex will be calculated uses `vec3Dsemiaxis_a_direction` vector rotation 
     (CCW direction, if look from end of `vec3Dplane_normal` vector) to specified angle and offset to specified distance
     @param angle_proportions - proportions array for splitting 360 degrees angle(without units, not matter). 
     `[90, 90, 90, 90]` returns result same as `[1, 1, 1, 1]`, in both cases will be created quadrangle belongs to plane
     @param distances - polygon vertexes radial distances array(offset length)</haxe_doc>
		</polygon3D_in_plane>
		<polygon3D_to_vec3Dfield public="1" set="method" line="1625">
			<f a="polygon3D">
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
			</f>
			<haxe_doc>returns vector field, which is vectors 3D, calculated from polygon center dot to each vertex. 
     Result will have form [[a, b, c], ... , [a, b, c]], depend of incoming data length
     @param polygon3D - must be of the form 
     [ polygon center dot 3D, polygon vertex first dot 3D , ... ,polygon vertex last dot 3D ]</haxe_doc>
		</polygon3D_to_vec3Dfield>
		<projection_vec3D_on_plane3D public="1" set="method" line="1635">
			<f a="vec3D:plane3D">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>returns vector 3D, which is `vec3D` vector projection on `plane3D` plane
     @param vec3D - vector 3D (a, b, c)
     @param plane3D - plane 3D (a, b, c, d), where (a, b, c) normal vector of plane, and (d) displacement from (0, 0, 0)</haxe_doc>
		</projection_vec3D_on_plane3D>
		<angle_vec3Dvec3D_projection_on_plane3D public="1" set="method" line="1666">
			<f a="vec3D1:vec3D2:plane3D:?rad" v=":::false">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<x path="Bool"/>
				<x path="Null"><x path="Float"/></x>
			</f>
			<meta><m n=":value"><e>{ rad : false }</e></m></meta>
			<haxe_doc>returns angle, which is projection of angle between `vec3D1` and `vec3D2` vectors to `plane3D`.  
     Result angle, calculated from projection of `vec3D1` to projection of `vec3D2` around plane normal  
     in ccw direction, and can be negative. In this case the positive angle in ccw direction between  
     projections of vectors can be represented as `360 + result(which is negative)`.
     @param vec3D1 - vector 3D (a, b, c)
     @param vec3D2 - vector 3D (a, b, c)
     @param plane3D - plane 3D (a, b, c, d), where (a, b, c) normal vector of plane, and (d) displacement from (0, 0, 0)
     @param rad - if true then radians angle, default false(degrees angle)</haxe_doc>
		</angle_vec3Dvec3D_projection_on_plane3D>
		<objAngle public="1" set="method" line="1702">
			<f a="?unit:?value" v=":0">
				<x path="geometryxd.AngleUnit"/>
				<x path="Float"/>
				<c path="geometryxd.Angle"/>
			</f>
			<meta><m n=":value"><e>{ value : 0 }</e></m></meta>
			<haxe_doc>* new angle object with few unit of measurement functionality. Created new instance angle default value is 0.
     * @param unit None = 0; Turn = 1; Mulp = 2; Quad = 3; Sext = 4; Rad = 5; Hexa = 6; Bdeg = 7; Deg = 8; Grad = 9; Marc = 10; Sarc = 11;
     * @param value</haxe_doc>
		</objAngle>
		<objDotXD public="1" set="method" line="1711">
			<f a="dot">
				<c path="Array"><x path="Float"/></c>
				<c path="geometryxd.DotXD"/>
			</f>
			<haxe_doc>* multidimensional dot object
     * @param dot coordinates
     * @return DotXD</haxe_doc>
		</objDotXD>
		<objDot3D public="1" set="method" line="1720">
			<f a="?x:?y:?z" v="0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="geometryxd.Dot3D"/>
			</f>
			<meta><m n=":value"><e>{ z : 0, y : 0, x : 0 }</e></m></meta>
			<haxe_doc>* 3D dot object. Default `[0,0,0]`.
     * @param x coordinate
     * @param y coordinate
     * @param z coordinate
     * @return Dot3D</haxe_doc>
		</objDot3D>
		<objVecXD public="1" set="method" line="1727">
			<f a="dotXDb:?dotXDa">
				<c path="geometryxd.DotXD"/>
				<c path="geometryxd.DotXD"/>
				<c path="geometryxd.VecXD"/>
			</f>
			<haxe_doc>* multidimentional vector object. Both dots must have same dimensions number, or `dotXDb` will returned
     * @param dotXDb end multidimensional dot of vector
     * @param dotXDa start multidimensional dot of vector. Default will be `[0,...,0]`</haxe_doc>
		</objVecXD>
		<objVec3D public="1" set="method" line="1734">
			<f a="dot3Db:?dot3Da">
				<c path="geometryxd.Dot3D"/>
				<c path="geometryxd.Dot3D"/>
				<c path="geometryxd.Vec3D"/>
			</f>
			<haxe_doc>* new 3D vector object
     * @param dot3Db end 3D dot of vector
     * @param dot3Da start 3D dot of vector. Default will be `[0,0,0]`</haxe_doc>
		</objVec3D>
		<new public="1" set="method" line="32">
			<f a="?message" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ message : true }</e></m></meta>
		</new>
		<haxe_doc><![CDATA[GeometryXD - multidimensional geometry manipulations. Primarily targeted for 3D objects (points, vectors, curves).  
  Additional methods allow manipulate with arrays.  
  Convert arrays. Int <-> Float <-> String <-> Int Arrays.  
  Sum arrays. Parallel sum of arrays elements.  
  Diff arrays. Parallel diff of arrays elements from first array elements.  
  Multiplying arrays. Parallel multiplication of arrays elements.  
  Sum array elements.  
  Calculate max abs value from Float Array.  
  Not pro level library.]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="geometryxd.Line3D" params="" file="./geometryxd/Line3D.hx">
		<eDot>
			<c path="geometryxd.Dot3D"/>
			<haxe_doc>internal property. Line end dot</haxe_doc>
		</eDot>
		<sDot>
			<c path="geometryxd.Dot3D"/>
			<haxe_doc>internal property. Line start dot</haxe_doc>
		</sDot>
		<geo expr="new GeometryXD(false)">
			<c path="geometryxd.GeometryXD"/>
			<meta><m n=":value"><e>new GeometryXD(false)</e></m></meta>
			<haxe_doc>internal usage of methods</haxe_doc>
		</geo>
		<new public="1" set="method" line="19">
			<f a="eDot:?sDot">
				<c path="geometryxd.Dot3D"/>
				<c path="geometryxd.Dot3D"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* new 3D line object.
     * @param eDot 3D line end dot
     * @param sDot 3D line start dot . Default will `[0,0,0]`</haxe_doc>
		</new>
		<haxe_doc>* 3D line object</haxe_doc>
	</class>
	<class path="geometryxd.NM" params="" file="./geometryxd/NM.hx">
		<sign_I public="1" get="inline" set="null" line="13">
			<f a="x">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc><![CDATA[return sign of Int. if x < 0 return -1, else return 1.
     @param x - number, sign of which should be calculated]]></haxe_doc>
		</sign_I>
		<sign_F public="1" get="inline" set="null" line="18">
			<f a="x">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc><![CDATA[return sign of Float. if x < 0 return -1, else return 1.
     @param x - number, sign of which should be calculated]]></haxe_doc>
		</sign_F>
		<sign3_I public="1" get="inline" set="null" line="24">
			<f a="x">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc><![CDATA[return sign of Int or 0. if x < 0 return -1, if x > 0 return 1, if x == 0 return 0.
     @param x - number, sign of which should be calculated]]></haxe_doc>
		</sign3_I>
		<sign3_F public="1" get="inline" set="null" line="29">
			<f a="x">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc><![CDATA[return sign of Float or 0. if x < 0 return -1, if x > 0 return 1, if x == 0 return 0.
     @param x - number, sign of which should be calculated]]></haxe_doc>
		</sign3_F>
		<sin_cos_cut public="1" get="inline" set="null" line="38">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>sin cos bonus function. Normalise sin cos, counted use vectors to -1...1 include boders.
     Need because sometimes (detected on python3 in the past) result of calculating sin cos
     uses vectors can be more then 1, or less then -1.
     For example 1.00000000001 etc. Just tiny correction, just for case.
     @param x - incoming sin cos value for check</haxe_doc>
		</sin_cos_cut>
		<degrees public="1" get="inline" set="null" line="43">
			<f a="angle">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>convert radians angle to degrees angle value
     @param angle - radians angle for recounting</haxe_doc>
		</degrees>
		<radians public="1" get="inline" set="null" line="48">
			<f a="angle">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>convert degrees angle to radians angle value
     @param angle - degrees angle for recounting</haxe_doc>
		</radians>
		<angle_quadrant public="1" set="method" line="59">
			<f a="angle:?rad" v=":false">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ rad : false }</e></m></meta>
			<haxe_doc><![CDATA[return the quadrant of any angle. 0 angle return 4 quadrant.
     For example use degrees:
     ... 0 < angle <= 90 return 1 quadrant 
     ... 90 < angle <= 180 return 2 quadrant 
     ... 180 < angle <= 270 return 3 quadrant 
     ... 270 < angle <= 360 return 4 quadrant 
     @param angle - angle for quadrant calculating
     @param rad - if true then radians angle, default false (degrees angle)]]></haxe_doc>
		</angle_quadrant>
		<steps_internal public="1" get="inline" set="null" line="82">
			<f a="xmin:xmax:n:?borders" v=":::false">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":value"><e>{ borders : false }</e></m></meta>
			<haxe_doc>split interval to equal steps
     @param xmin - minimum border
     @param xmax - maximum border
     @param n - steps number
     @param borders - if true then add borders into result</haxe_doc>
		</steps_internal>
		<steps_external public="1" set="method" line="107">
			<f a="smin:smax:n:direction">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc><![CDATA[repeat step multiple times.
     f(1, 5, 3, -1) return [-11, -7, -3, 1, 5]
     f(1, 5, 3, 0) return [-11, -7, -3, 1, 5, 9, 13, 17]
     f(1, 5, 3, 1) return [1, 5, 9, 13, 17]
     @param smin - step minimum border
     @param smax - step maximum border
     @param n - repeat number
     @param direction - if < 0 then from negative to minimum border direction. if > 0 then from maximum border to positive direction. if == 0 then both]]></haxe_doc>
		</steps_external>
		<new public="1" set="method" line="7"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* number manipulation</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="geometryxd.Ray3D" params="" file="./geometryxd/Ray3D.hx">
		<vec>
			<c path="geometryxd.Vec3D"/>
			<haxe_doc>internal property. 3D ray vector</haxe_doc>
		</vec>
		<sDot>
			<c path="geometryxd.Dot3D"/>
			<haxe_doc>internal property. 3D ray start dot</haxe_doc>
		</sDot>
		<geo expr="new GeometryXD(false)">
			<c path="geometryxd.GeometryXD"/>
			<meta><m n=":value"><e>new GeometryXD(false)</e></m></meta>
			<haxe_doc>internal usage of methods</haxe_doc>
		</geo>
		<useDot public="1" set="method" line="25"><f a=""><x path="Void"/></f></useDot>
		<useVec public="1" set="method" line="26"><f a=""><x path="Void"/></f></useVec>
		<useArray public="1" set="method" line="27"><f a=""><x path="Void"/></f></useArray>
		<fromDot public="1" set="method" line="29"><f a=""><x path="Void"/></f></fromDot>
		<fromVec public="1" set="method" line="30"><f a=""><x path="Void"/></f></fromVec>
		<fromArray public="1" set="method" line="31"><f a=""><x path="Void"/></f></fromArray>
		<valueDot public="1" set="method" line="33"><f a=""><x path="Void"/></f></valueDot>
		<valueVec public="1" set="method" line="34"><f a=""><x path="Void"/></f></valueVec>
		<valueDotM public="1" set="method" line="36"><f a=""><x path="Void"/></f></valueDotM>
		<valueVecM public="1" set="method" line="37"><f a=""><x path="Void"/></f></valueVecM>
		<fromDotM public="1" set="method" line="39"><f a=""><x path="Void"/></f></fromDotM>
		<fromVecM public="1" set="method" line="40"><f a=""><x path="Void"/></f></fromVecM>
		<fromFullM public="1" set="method" line="41"><f a=""><x path="Void"/></f></fromFullM>
		<s public="1" set="method" line="49">
			<f a=""><c path="geometryxd.Dot3D"/></f>
			<haxe_doc>* start dot of ray</haxe_doc>
		</s>
		<v public="1" set="method" line="56">
			<f a=""><c path="geometryxd.Vec3D"/></f>
			<haxe_doc>* vector of ray</haxe_doc>
		</v>
		<rotate public="1" set="method" line="66">
			<f a="axis:angle:?cDot">
				<c path="geometryxd.Vec3D"/>
				<c path="geometryxd.Angle"/>
				<c path="geometryxd.Dot3D"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* rotate ray around axis to angle
     * @param axis rotation axis
     * @param angle rotation angle
     * @param cDot rotation center 3D dot. if present then ray start 3D dot will be rotated too, around cDot</haxe_doc>
		</rotate>
		<offset public="1" set="method" line="76">
			<f a="v:d">
				<c path="geometryxd.Vec3D"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* offset ray along vector to distance
     * @param v offset vector
     * @param d offset distance</haxe_doc>
		</offset>
		<scale public="1" set="method" line="86">
			<f a="sxyz:?cDot:?full" v="::false">
				<c path="Array"><x path="Float"/></c>
				<c path="geometryxd.Dot3D"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ full : false }</e></m></meta>
			<haxe_doc>* scale ray start dot coordinates, relative to the scale center dot. Default is ray direction vector will not changed
     * @param sxyz scales for axes `[sx,sy,sz]`
     * @param cDot scale center dot
     * @param full scale ray direction vector too. Default is false (ray direction  will not changed). Scale center is `[0,0,0]`</haxe_doc>
		</scale>
		<dot public="1" set="method" line="95">
			<f a="d">
				<x path="Float"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>* dot on ray
     * @param d displacement from ray start dot, along ray vector</haxe_doc>
		</dot>
		<new public="1" set="method" line="20">
			<f a="vec:?sDot">
				<c path="geometryxd.Vec3D"/>
				<c path="geometryxd.Dot3D"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* new 3D ray object
     * @param vec ray vector
     * @param sDot ray start dot</haxe_doc>
		</new>
	</class>
	<class path="geometryxd.Vec3D" params="" file="./geometryxd/Vec3D.hx">
		<x public="1">
			<x path="Float"/>
			<haxe_doc>* x coordinate of vec</haxe_doc>
		</x>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>* y coordinate of vec</haxe_doc>
		</y>
		<z public="1">
			<x path="Float"/>
			<haxe_doc>* z coordinate of vec</haxe_doc>
		</z>
		<geo expr="new GeometryXD(false)">
			<c path="geometryxd.GeometryXD"/>
			<meta><m n=":value"><e>new GeometryXD(false)</e></m></meta>
			<haxe_doc>* internal usage of methods</haxe_doc>
		</geo>
		<vd get="inline" set="null" line="46">
			<f a="c">
				<c path="Array"><x path="Float"/></c>
				<c path="geometryxd.Vec3D"/>
			</f>
			<haxe_doc>* internal function. Return Vec3D object from 3D dot coordinates
     * @param c 3D dot coordinates array `[x,y,z]`</haxe_doc>
		</vd>
		<fromArray public="1" set="method" line="54">
			<f a="xyz">
				<c path="Array"><x path="Float"/></c>
				<c path="geometryxd.Vec3D"/>
			</f>
			<haxe_doc>* new Vec3D object from array of coordinates. Used first three array elements. Not enough length replaced uses 0.
     * @param xyz array of 3D vector coordinates `[x,y,z]`</haxe_doc>
		</fromArray>
		<useArray public="1" set="method" line="64">
			<f a="xyz">
				<c path="Array"><x path="Float"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* set `x,y,z` properties using array of coordinates. Used first three array elements. Not enough length replaced uses 0.
     * @param xyz array of 3D vector coordinates `[x,y,z]`</haxe_doc>
		</useArray>
		<useM public="1" set="method" line="74">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* mirror 3D vector coordinates. `[1,2,3]` -> `[-1,-2,-3]`]]></haxe_doc>
		</useM>
		<useMx public="1" set="method" line="83">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* mirror 3D vector x coordinate. `[1,2,3]` -> `[-1,2,3]`]]></haxe_doc>
		</useMx>
		<useMy public="1" set="method" line="90">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* mirror 3D vector y coordinate. `[1,2,3]` -> `[1,-2,3]`]]></haxe_doc>
		</useMy>
		<useMz public="1" set="method" line="97">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* mirror 3D vector z coordinate. `[1,2,3]` -> `[1,2,-3]`]]></haxe_doc>
		</useMz>
		<useMxy public="1" set="method" line="104">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* mirror 3D vector x y coordinates. `[1,2,3]` -> `[-1,-2,3]`]]></haxe_doc>
		</useMxy>
		<useMxz public="1" set="method" line="112">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* mirror 3D vector x z coordinates. `[1,2,3]` -> `[-1,2,-3]`]]></haxe_doc>
		</useMxz>
		<useMyz public="1" set="method" line="120">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* mirror 3D vector y z coordinates. `[1,2,3]` -> `[1,-2,-3]`]]></haxe_doc>
		</useMyz>
		<dn public="1" set="method" line="129">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* number of vector dimensions</haxe_doc>
		</dn>
		<value public="1" set="method" line="137">
			<f a=""><c path="Array"><x path="Float"/></c></f>
			<haxe_doc>* array of vector coordinates `[x,y,z]`</haxe_doc>
		</value>
		<valueM public="1" set="method" line="144">
			<f a=""><c path="Array"><x path="Float"/></c></f>
			<haxe_doc>* array of mirrored values of vec coordinates. If `value()` = `[1,2,3]` return `[-1,-2,-3]`</haxe_doc>
		</valueM>
		<valueMx public="1" set="method" line="151">
			<f a=""><c path="Array"><x path="Float"/></c></f>
			<haxe_doc>* array of values of vec coordinates with mirrored x coordinate. If `value()` = `[1,2,3]` return `[-1,2,3]`</haxe_doc>
		</valueMx>
		<valueMy public="1" set="method" line="158">
			<f a=""><c path="Array"><x path="Float"/></c></f>
			<haxe_doc>* array of values of vec coordinates with mirrored y coordinate. If `value()` = `[1,2,3]` return `[1,-2,3]`</haxe_doc>
		</valueMy>
		<valueMz public="1" set="method" line="165">
			<f a=""><c path="Array"><x path="Float"/></c></f>
			<haxe_doc>* array of values of vec coordinates with mirrored z coordinate. If `value()` = `[1,2,3]` return `[1,2,-3]`</haxe_doc>
		</valueMz>
		<valueMxy public="1" set="method" line="172">
			<f a=""><c path="Array"><x path="Float"/></c></f>
			<haxe_doc>* array of values of vec coordinates with mirrored x y coordinates. If `value()` = `[1,2,3]` return `[-1,-2,3]`</haxe_doc>
		</valueMxy>
		<valueMxz public="1" set="method" line="179">
			<f a=""><c path="Array"><x path="Float"/></c></f>
			<haxe_doc>* array of values of vec coordinates with mirrored x z coordinates. If `value()` = `[1,2,3]` return `[-1,2,-3]`</haxe_doc>
		</valueMxz>
		<valueMyz public="1" set="method" line="186">
			<f a=""><c path="Array"><x path="Float"/></c></f>
			<haxe_doc>* array of values of vec coordinates with mirrored y z coordinates. If `value()` = `[1,2,3]` return `[1,-2,-3]`</haxe_doc>
		</valueMyz>
		<valueOne public="1" set="method" line="194">
			<f a=""><c path="Array"><x path="Float"/></c></f>
			<haxe_doc>* value of vector recounted to length equal 1</haxe_doc>
		</valueOne>
		<valueOneM public="1" set="method" line="201">
			<f a=""><c path="Array"><x path="Float"/></c></f>
			<haxe_doc>* value of mirrored vector, recounted to length equal 1</haxe_doc>
		</valueOneM>
		<valueOneMx public="1" set="method" line="208">
			<f a=""><c path="Array"><x path="Float"/></c></f>
			<haxe_doc>* value of vector with mirrored x coordinate, recounted to length equal 1</haxe_doc>
		</valueOneMx>
		<valueOneMy public="1" set="method" line="215">
			<f a=""><c path="Array"><x path="Float"/></c></f>
			<haxe_doc>* value of vector with mirrored y coordinate, recounted to length equal 1</haxe_doc>
		</valueOneMy>
		<valueOneMz public="1" set="method" line="222">
			<f a=""><c path="Array"><x path="Float"/></c></f>
			<haxe_doc>* value of vector with mirrored z coordinate, recounted to length equal 1</haxe_doc>
		</valueOneMz>
		<valueOneMxy public="1" set="method" line="229">
			<f a=""><c path="Array"><x path="Float"/></c></f>
			<haxe_doc>* value of vector with mirrored x y coordinates, recounted to length equal 1</haxe_doc>
		</valueOneMxy>
		<valueOneMxz public="1" set="method" line="236">
			<f a=""><c path="Array"><x path="Float"/></c></f>
			<haxe_doc>* value of vector with mirrored x z coordinates, recounted to length equal 1</haxe_doc>
		</valueOneMxz>
		<valueOneMyz public="1" set="method" line="243">
			<f a=""><c path="Array"><x path="Float"/></c></f>
			<haxe_doc>* value of vector with mirrored y z coordinates, recounted to length equal 1</haxe_doc>
		</valueOneMyz>
		<vec3DM public="1" set="method" line="251">
			<f a=""><c path="geometryxd.Vec3D"/></f>
			<haxe_doc>* new 3D vector object with mirrored coordinates. if `value()` = `[1,2,3]` return vec3DM().value() = `[-1,-2,-3]`</haxe_doc>
		</vec3DM>
		<vec3DMx public="1" set="method" line="258">
			<f a=""><c path="geometryxd.Vec3D"/></f>
			<haxe_doc>* new 3D vector object with mirrored x coordinate. if `value()` = `[1,2,3]` return vec3DM().value() = `[-1,2,3]`</haxe_doc>
		</vec3DMx>
		<vec3DMy public="1" set="method" line="265">
			<f a=""><c path="geometryxd.Vec3D"/></f>
			<haxe_doc>* new 3D vector object with mirrored y coordinate. if `value()` = `[1,2,3]` return vec3DM().value() = `[1,-2,3]`</haxe_doc>
		</vec3DMy>
		<vec3DMz public="1" set="method" line="272">
			<f a=""><c path="geometryxd.Vec3D"/></f>
			<haxe_doc>* new 3D vector object with mirrored z coordinate. if `value()` = `[1,2,3]` return vec3DM().value() = `[1,2,-3]`</haxe_doc>
		</vec3DMz>
		<vec3DMxy public="1" set="method" line="279">
			<f a=""><c path="geometryxd.Vec3D"/></f>
			<haxe_doc>* new 3D vector object with mirrored x y coordinates. if `value()` = `[1,2,3]` return vec3DM().value() = `[-1,-2,3]`</haxe_doc>
		</vec3DMxy>
		<vec3DMxz public="1" set="method" line="286">
			<f a=""><c path="geometryxd.Vec3D"/></f>
			<haxe_doc>* new 3D vector object with mirrored x z coordinates. if `value()` = `[1,2,3]` return vec3DM().value() = `[-1,2,-3]`</haxe_doc>
		</vec3DMxz>
		<vec3DMyz public="1" set="method" line="293">
			<f a=""><c path="geometryxd.Vec3D"/></f>
			<haxe_doc>* new 3D vector object with mirrored y z coordinates. if `value()` = `[1,2,3]` return vec3DM().value() = `[1,-2,-3]`</haxe_doc>
		</vec3DMyz>
		<vec3Done public="1" set="method" line="301">
			<f a=""><c path="geometryxd.Vec3D"/></f>
			<haxe_doc>* new 3D vector object, recounted to length equal 1</haxe_doc>
		</vec3Done>
		<vec3DoneM public="1" set="method" line="308">
			<f a=""><c path="geometryxd.Vec3D"/></f>
			<haxe_doc>* new 3D vector object, with mirrored coordinates, recounted to length equal 1</haxe_doc>
		</vec3DoneM>
		<vec3DoneMx public="1" set="method" line="315">
			<f a=""><c path="geometryxd.Vec3D"/></f>
			<haxe_doc>* new 3D vector object, with mirrored x coordinate, recounted to length equal 1</haxe_doc>
		</vec3DoneMx>
		<vec3DoneMy public="1" set="method" line="322">
			<f a=""><c path="geometryxd.Vec3D"/></f>
			<haxe_doc>* new 3D vector object, with mirrored y coordinate, recounted to length equal 1</haxe_doc>
		</vec3DoneMy>
		<vec3DoneMz public="1" set="method" line="329">
			<f a=""><c path="geometryxd.Vec3D"/></f>
			<haxe_doc>* new 3D vector object, with mirrored z coordinate, recounted to length equal 1</haxe_doc>
		</vec3DoneMz>
		<vec3DoneMxy public="1" set="method" line="336">
			<f a=""><c path="geometryxd.Vec3D"/></f>
			<haxe_doc>* new 3D vector object, with mirrored x y coordinates, recounted to length equal 1</haxe_doc>
		</vec3DoneMxy>
		<vec3DoneMxz public="1" set="method" line="343">
			<f a=""><c path="geometryxd.Vec3D"/></f>
			<haxe_doc>* new 3D vector object, with mirrored x z coordinates, recounted to length equal 1</haxe_doc>
		</vec3DoneMxz>
		<vec3DoneMyz public="1" set="method" line="350">
			<f a=""><c path="geometryxd.Vec3D"/></f>
			<haxe_doc>* new 3D vector object, with mirrored y z coordinates, recounted to length equal 1</haxe_doc>
		</vec3DoneMyz>
		<copy public="1" set="method" line="358">
			<f a=""><c path="geometryxd.Vec3D"/></f>
			<haxe_doc>* new 3D vector object with same coordinates. if `value()` = `[1,2,3]` return vec3DM().value() = `[1,2,3]`</haxe_doc>
		</copy>
		<new public="1" set="method" line="30">
			<f a="dot3Db:?dot3Da">
				<c path="geometryxd.Dot3D"/>
				<c path="geometryxd.Dot3D"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* new 3D vector object
     * @param dot3Db end 3D dot of vector
     * @param dot3Da start 3D dot of vector. Default will be `[0,0,0]`</haxe_doc>
		</new>
		<haxe_doc>* 3D vector object</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="geometryxd.VecXD" params="" file="./geometryxd/VecXD.hx">
		<coordinates>
			<c path="Array"><x path="Float"/></c>
			<haxe_doc>* internal property. array of vector coordinates</haxe_doc>
		</coordinates>
		<geo expr="new GeometryXD(false)">
			<c path="geometryxd.GeometryXD"/>
			<meta><m n=":value"><e>new GeometryXD(false)</e></m></meta>
			<haxe_doc>* internal usage of methods</haxe_doc>
		</geo>
		<vd get="inline" set="null" line="31">
			<f a="c">
				<c path="Array"><x path="Float"/></c>
				<c path="geometryxd.VecXD"/>
			</f>
			<haxe_doc>* internal function. Return VecXD object from multidimensional dot coordinates
     * @param c multidimensional dot coordinates array `[x,y,...,z]`</haxe_doc>
		</vd>
		<useArray public="1" set="method" line="40">
			<f a="coordinates">
				<c path="Array"><x path="Float"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* set vector coordinates properties using array of coordinates.
     * @param coordinates array of XD vector coordinates `[x,y,...,z]`</haxe_doc>
		</useArray>
		<fromArray public="1" set="method" line="48">
			<f a="coordinates">
				<c path="Array"><x path="Float"/></c>
				<c path="geometryxd.VecXD"/>
			</f>
			<haxe_doc>* new VecXD object from array of coordinates.
     * @param coordinates array of multidimensional vector coordinates `[x,y,...,z]`</haxe_doc>
		</fromArray>
		<value public="1" set="method" line="53"><f a=""><c path="Array"><x path="Float"/></c></f></value>
		<dn public="1" set="method" line="60">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* number of vector dimensions</haxe_doc>
		</dn>
		<valueM public="1" set="method" line="67">
			<f a=""><c path="Array"><x path="Float"/></c></f>
			<haxe_doc>* array of mirrored values of vector coordinates. If `value` = `[1,2,3,-4]` return `[-1,-2,-3,4]`</haxe_doc>
		</valueM>
		<vecXDM public="1" set="method" line="75">
			<f a=""><c path="geometryxd.VecXD"/></f>
			<haxe_doc>* new multidimensional vector object with mirrored coordinates. If `value` = `[1,2,3,-4]` return vecXD().value = `[-1,-2,-3,4]`</haxe_doc>
		</vecXDM>
		<copy public="1" set="method" line="82">
			<f a=""><c path="geometryxd.VecXD"/></f>
			<haxe_doc>* new multidimensional vector object with same coordinates. if `value` = `[1,2,3,-4]` return vecXD().value = `[1,2,3,-4]`</haxe_doc>
		</copy>
		<new public="1" set="method" line="17">
			<f a="eDot:?sDot">
				<c path="geometryxd.DotXD"/>
				<c path="geometryxd.DotXD"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* new multidimentional vector object. Both dots must have same dimensions number, or eDot will used
     * @param eDot end dot of multidimensional vector
     * @param sDot start dot of multidimensional vector. Default will be `[0,...,0]`</haxe_doc>
		</new>
		<haxe_doc>* multidimensional vector object</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="haxe.Function" params="" file="/usr/share/haxe/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with any function type.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<meta><m n=":callable"/></meta>
		<impl><class path="haxe._Constraints.Function_Impl_" params="" file="/usr/share/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.FlatEnum" params="" file="/usr/share/haxe/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with an enum instance if all constructors of the enum
	require no arguments.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<impl><class path="haxe._Constraints.FlatEnum_Impl_" params="" file="/usr/share/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.Constructible" params="T" file="/usr/share/haxe/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc><![CDATA[This type unifies with any instance of classes that have a constructor
	which

	  * is `public` and
	  * unifies with the type used for type parameter `T`.

	If a type parameter `A` is assigned to a type parameter `B` which is constrained
	to `Constructible<T>`, A must be explicitly constrained to
	`Constructible<T>` as well.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.]]></haxe_doc>
		<impl><class path="haxe._Constraints.Constructible_Impl_" params="" file="/usr/share/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.EnumTools" params="" file="/usr/share/haxe/std/haxe/EnumTools.hx" extern="1">
		<getName public="1" params="T" get="inline" set="null" line="52" static="1">
			<f a="e">
				<x path="Enum"><c path="getName.T"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.

		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
		
			pack1.pack2.(...).packN.EnumName

		If `e` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `e` has no package, the enum name is returned.

		If `e` is `null`, the result is unspecified.

		The enum name does not include any type parameters.</haxe_doc>
		</getName>
		<createByName public="1" params="T" get="inline" set="null" line="65" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createByName.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createByName.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.

		If `e` or `constr` is `null`, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByName>
		<createByIndex public="1" params="T" get="inline" set="null" line="81" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createByIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createByIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.

		The constructor indices are preserved from Haxe syntax, so the first
		declared is index 0, the next index 1 etc.

		If `e` or `index` is `null`, or if enum `e` has no constructor
		corresponding to index `index`, or if the number of elements in `params`
		does not match the expected number of constructor arguments, or if any
		argument has an invalid type, the result is unspecified.</haxe_doc>
		</createByIndex>
		<createAll public="1" params="T" get="inline" set="null" line="98" static="1">
			<f a="e">
				<x path="Enum"><c path="createAll.T"/></x>
				<c path="Array"><c path="createAll.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.

		This may return the empty Array `[]` if all constructors of `e` require
		arguments.

		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</createAll>
		<getConstructors public="1" params="T" get="inline" set="null" line="110" static="1">
			<f a="e">
				<x path="Enum"><c path="getConstructors.T"/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.

		The order of the constructor names in the returned Array is preserved
		from the original syntax.

		If `c` is `null`, the result is unspecified.</haxe_doc>
		</getConstructors>
		<haxe_doc>This class provides advanced methods on enums. It is ideally used with
	`using EnumTools` and then acts as an
	  [extension](https://haxe.org/manual/lf-static-extension.html) to the
	  `enum` types.

	If the first argument to any of the methods is `null`, the result is
	unspecified.</haxe_doc>
	</class>
	<class path="haxe.EnumValueTools" params="" file="/usr/share/haxe/std/haxe/EnumTools.hx" module="haxe.EnumTools" extern="1">
		<equals public="1" params="T" get="inline" set="null" line="133" static="1">
			<f a="a:b">
				<c path="equals.T"/>
				<c path="equals.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.

		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors (if there are any).

		If `a` or `b` are `null`, the result is unspecified.</haxe_doc>
		</equals>
		<getName public="1" get="inline" set="null" line="144" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.

		The result String does not contain any constructor arguments.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getName>
		<getParameters public="1" get="inline" set="null" line="158" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.

		If `e` has no arguments, the result is `[]`.

		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getParameters>
		<getIndex public="1" get="inline" set="null" line="170" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance `e`.

		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getIndex>
		<haxe_doc>This class provides advanced methods on enum values. It is ideally used with
	`using EnumValueTools` and then acts as an
	  [extension](https://haxe.org/manual/lf-static-extension.html) to the
	  `EnumValue` types.

	If the first argument to any of the methods is `null`, the result is
	unspecified.</haxe_doc>
	</class>
	<abstract path="haxe.Int32" params="" file="/usr/share/haxe/std/haxe/Int32.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast field="toFloat"><x path="Float"/></icast>
		</to>
		<haxe_doc>Int32 provides a 32-bit integer with consistent overflow behavior across
	all platforms.</haxe_doc>
		<impl><class path="haxe._Int32.Int32_Impl_" params="" file="/usr/share/haxe/std/haxe/Int32.hx" private="1" module="haxe.Int32"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.Int64" params="" file="/usr/share/haxe/std/haxe/Int64.hx">
		<from>
			<icast><t path="haxe._Int64.__Int64"/></icast>
			<icast field="ofInt"><x path="Int"/></icast>
		</from>
		<this><t path="haxe._Int64.__Int64"/></this>
		<to><icast><t path="haxe._Int64.__Int64"/></icast></to>
		<haxe_doc>A cross-platform signed 64-bit integer.
	Int64 instances can be created from two 32-bit words using `Int64.make()`.</haxe_doc>
		<impl><class path="haxe._Int64.Int64_Impl_" params="" file="/usr/share/haxe/std/haxe/Int64.hx" private="1" module="haxe.Int64">
	<high public="1" get="accessor" set="null" static="1">
		<x path="haxe.Int32"/>
		<meta><m n=":impl"/></meta>
	</high>
	<low public="1" get="accessor" set="null" static="1">
		<x path="haxe.Int32"/>
		<meta><m n=":impl"/></meta>
	</low>
	<meta><m n=":keep"/></meta>
</class></impl>
	</abstract>
	<typedef path="haxe._Int64.__Int64" params="" file="/usr/share/haxe/std/haxe/Int64.hx" private="1" module="haxe.Int64">
		<c path="haxe._Int64.___Int64"/>
		<haxe_doc>This typedef will fool `@:coreApi` into thinking that we are using
	the same underlying type, even though it might be different on
	specific platforms.</haxe_doc>
	</typedef>
	<class path="haxe.Log" params="" file="/usr/share/haxe/std/haxe/Log.hx">
		<formatOutput public="1" set="method" line="33" static="1">
			<f a="v:infos">
				<d/>
				<t path="haxe.PosInfos"/>
				<c path="String"/>
			</f>
			<haxe_doc>Format the output of `trace` before printing it.</haxe_doc>
		</formatOutput>
		<trace public="1" set="dynamic" line="62" static="1">
			<f a="v:?infos">
				<d/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Outputs `v` in a platform-dependent way.

		The second parameter `infos` is injected by the compiler and contains
		information about the position where the `trace()` call was made.

		This method can be rebound to a custom function:

			var oldTrace = haxe.Log.trace; // store old function
			haxe.Log.trace = function(v, ?infos) {
			  // handle trace
			}
			...
			haxe.Log.trace = oldTrace;

		If it is bound to null, subsequent calls to `trace()` will cause an
		exception.</haxe_doc>
		</trace>
		<haxe_doc>Log primarily provides the `trace()` method, which is invoked upon a call to
	`trace()` in Haxe code.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<typedef path="haxe.PosInfos" params="" file="/usr/share/haxe/std/haxe/PosInfos.hx">
		<a>
			<methodName><c path="String"/></methodName>
			<lineNumber><x path="Int"/></lineNumber>
			<fileName><c path="String"/></fileName>
			<customParams>
				<x path="Null"><c path="Array"><d/></c></x>
				<meta><m n=":optional"/></meta>
			</customParams>
			<className><c path="String"/></className>
		</a>
		<haxe_doc>`PosInfos` is a magic type which can be used to generate position information
	into the output for debugging use.

	If a function has a final optional argument of this type, i.e.
	`(..., ?pos:haxe.PosInfos)`, each call to that function which does not assign
	a value to that argument has its position added as call argument.

	This can be used to track positions of calls in e.g. a unit testing
	framework.</haxe_doc>
	</typedef>
	<abstract path="haxe.ds.HashMap" params="K:V" file="/usr/share/haxe/std/haxe/ds/HashMap.hx">
		<this><c path="haxe.ds._HashMap.HashMapData">
	<c path="haxe.ds.HashMap.K"/>
	<c path="haxe.ds.HashMap.V"/>
</c></this>
		<haxe_doc>HashMap allows mapping of hashable objects to arbitrary values.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<impl><class path="haxe.ds._HashMap.HashMap_Impl_" params="" file="/usr/share/haxe/std/haxe/ds/HashMap.hx" private="1" module="haxe.ds.HashMap"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.ds.IntMap" params="T" file="/usr/share/haxe/std/haxe/ds/IntMap.hx" extern="1">
		<implements path="haxe.IMap">
			<x path="Int"/>
			<c path="haxe.ds.IntMap.T"/>
		</implements>
		<set public="1" set="method">
			<f a="key:value">
				<x path="Int"/>
				<c path="haxe.ds.IntMap.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" set="method">
			<f a="key">
				<x path="Int"/>
				<x path="Null"><c path="haxe.ds.IntMap.T"/></x>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" set="method">
			<f a="key">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method">
			<f a="key">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method">
			<f a=""><t path="Iterator"><x path="Int"/></t></f>
			<haxe_doc>See `Map.keys`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</keys>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="haxe.ds.IntMap.T"/></t></f>
			<haxe_doc>See `Map.iterator`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</iterator>
		<keyValueIterator public="1" set="method">
			<f a=""><t path="KeyValueIterator">
	<x path="Int"/>
	<c path="haxe.ds.IntMap.T"/>
</t></f>
			<haxe_doc>See `Map.keyValueIterator`</haxe_doc>
		</keyValueIterator>
		<copy public="1" set="method">
			<f a=""><c path="haxe.ds.IntMap"><c path="haxe.ds.IntMap.T"/></c></f>
			<haxe_doc>See `Map.copy`</haxe_doc>
		</copy>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>See `Map.toString`</haxe_doc>
		</toString>
		<clear public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>See `Map.clear`</haxe_doc>
		</clear>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new IntMap.</haxe_doc>
		</new>
		<haxe_doc>IntMap allows mapping of Int keys to arbitrary values.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
	</class>
	<abstract path="haxe.ds.Map" params="K:V" file="/usr/share/haxe/std/haxe/ds/Map.hx">
		<from>
			<icast field="fromStringMap"><c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c></icast>
			<icast field="fromIntMap"><c path="haxe.ds.IntMap"><c path="fromIntMap.V"/></c></icast>
			<icast field="fromObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="fromObjectMap.K"/>
	<c path="fromObjectMap.V"/>
</c></icast>
		</from>
		<this><c path="haxe.IMap">
	<c path="haxe.ds.Map.K"/>
	<c path="haxe.ds.Map.V"/>
</c></this>
		<to>
			<icast field="toStringMap"><c path="haxe.ds.StringMap"><c path="toStringMap.V"/></c></icast>
			<icast field="toIntMap"><c path="haxe.ds.IntMap"><c path="toIntMap.V"/></c></icast>
			<icast field="toEnumValueMapMap"><c path="haxe.ds.EnumValueMap">
	<c path="toEnumValueMapMap.K"/>
	<c path="toEnumValueMapMap.V"/>
</c></icast>
			<icast field="toObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="toObjectMap.K"/>
	<c path="toObjectMap.V"/>
</c></icast>
		</to>
		<haxe_doc><![CDATA[Map allows key to value mapping for arbitrary value types, and many key
	types.

	This is a multi-type abstract, it is instantiated as one of its
	specialization types depending on its type parameters.

	A Map can be instantiated without explicit type parameters. Type inference
	will then determine the type parameters from the usage.

	Maps can also be created with `[key1 => value1, key2 => value2]` syntax.

	Map is an abstract type, it is not available at runtime.

	@see https://haxe.org/manual/std-Map.html]]></haxe_doc>
		<meta><m n=":multiType"><e>@:followWithAbstracts K</e></m></meta>
		<impl><class path="haxe.ds._Map.Map_Impl_" params="" file="/usr/share/haxe/std/haxe/ds/Map.hx" private="1" module="haxe.ds.Map"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.ds.ObjectMap" params="K:V" file="/usr/share/haxe/std/haxe/ds/ObjectMap.hx" extern="1">
		<implements path="haxe.IMap">
			<c path="haxe.ds.ObjectMap.K"/>
			<c path="haxe.ds.ObjectMap.V"/>
		</implements>
		<set public="1" set="method">
			<f a="key:value">
				<c path="haxe.ds.ObjectMap.K"/>
				<c path="haxe.ds.ObjectMap.V"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" set="method">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Null"><c path="haxe.ds.ObjectMap.V"/></x>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" set="method">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method">
			<f a=""><t path="Iterator"><c path="haxe.ds.ObjectMap.K"/></t></f>
			<haxe_doc>See `Map.keys`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</keys>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="haxe.ds.ObjectMap.V"/></t></f>
			<haxe_doc>See `Map.iterator`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</iterator>
		<keyValueIterator public="1" set="method">
			<f a=""><t path="KeyValueIterator">
	<c path="haxe.ds.ObjectMap.K"/>
	<c path="haxe.ds.ObjectMap.V"/>
</t></f>
			<haxe_doc>See `Map.keyValueIterator`</haxe_doc>
		</keyValueIterator>
		<copy public="1" set="method">
			<f a=""><c path="haxe.ds.ObjectMap">
	<c path="haxe.ds.ObjectMap.K"/>
	<c path="haxe.ds.ObjectMap.V"/>
</c></f>
			<haxe_doc>See `Map.copy`</haxe_doc>
		</copy>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>See `Map.toString`</haxe_doc>
		</toString>
		<clear public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>See `Map.clear`</haxe_doc>
		</clear>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new ObjectMap.</haxe_doc>
		</new>
		<haxe_doc>ObjectMap allows mapping of object keys to arbitrary values.

	On static targets, the keys are considered to be strong references. Refer
	to `haxe.ds.WeakMap` for a weak reference version.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
	</class>
	<abstract path="haxe.ds.ReadOnlyArray" params="T" file="/usr/share/haxe/std/haxe/ds/ReadOnlyArray.hx">
		<from><icast><c path="Array"><c path="haxe.ds.ReadOnlyArray.T"/></c></icast></from>
		<this><c path="Array"><c path="haxe.ds.ReadOnlyArray.T"/></c></this>
		<haxe_doc>`ReadOnlyArray` is an abstract over an ordinary `Array` which only exposes
	APIs that don't modify the instance, hence "read-only".

	Note that this doesn't necessarily mean that the instance is *immutable*.
	Other code holding a reference to the underlying `Array` can still modify it,
	and the reference can be obtained with a `cast`.</haxe_doc>
		<meta><m n=":forward">
	<e>concat</e>
	<e>copy</e>
	<e>filter</e>
	<e>indexOf</e>
	<e>iterator</e>
	<e>join</e>
	<e>lastIndexOf</e>
	<e>map</e>
	<e>slice</e>
	<e>toString</e>
</m></meta>
		<impl><class path="haxe.ds._ReadOnlyArray.ReadOnlyArray_Impl_" params="" file="/usr/share/haxe/std/haxe/ds/ReadOnlyArray.hx" private="1" module="haxe.ds.ReadOnlyArray">
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>The length of `this` Array.</haxe_doc>
	</length>
	<meta><m n=":keep"/></meta>
</class></impl>
	</abstract>
	<class path="haxe.ds.StringMap" params="T" file="/usr/share/haxe/std/haxe/ds/StringMap.hx" extern="1">
		<implements path="haxe.IMap">
			<c path="String"/>
			<c path="haxe.ds.StringMap.T"/>
		</implements>
		<set public="1" set="method">
			<f a="key:value">
				<c path="String"/>
				<c path="haxe.ds.StringMap.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" set="method">
			<f a="key">
				<c path="String"/>
				<x path="Null"><c path="haxe.ds.StringMap.T"/></x>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" set="method">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>See `Map.keys`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</keys>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="haxe.ds.StringMap.T"/></t></f>
			<haxe_doc>See `Map.iterator`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</iterator>
		<keyValueIterator public="1" set="method">
			<f a=""><t path="KeyValueIterator">
	<c path="String"/>
	<c path="haxe.ds.StringMap.T"/>
</t></f>
			<haxe_doc>See `Map.keyValueIterator`</haxe_doc>
		</keyValueIterator>
		<copy public="1" set="method">
			<f a=""><c path="haxe.ds.StringMap"><c path="haxe.ds.StringMap.T"/></c></f>
			<haxe_doc>See `Map.copy`</haxe_doc>
		</copy>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>See `Map.toString`</haxe_doc>
		</toString>
		<clear public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>See `Map.clear`</haxe_doc>
		</clear>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringMap.</haxe_doc>
		</new>
		<haxe_doc>StringMap allows mapping of String keys to arbitrary values.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
	</class>
	<typedef path="haxe.io.BytesData" params="" file="/usr/share/haxe/std/haxe/io/BytesData.hx"><c path="Array"><x path="Int"/></c></typedef>
</haxe>